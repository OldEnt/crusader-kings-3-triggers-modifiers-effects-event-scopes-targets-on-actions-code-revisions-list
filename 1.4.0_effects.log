Effect Documentation:

--------------------

add_dynasty_modifier - Add a modifier to a dynasty
add_dynasty_modifier = name
add_dynasty_modifier = { modifier = name days/weeks/months/years = int }
You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
Supported Scopes: dynasty

--------------------

add_dynasty_perk - Adds dynasty perk. add_dynasty_perk = key
Supported Scopes: dynasty

--------------------

add_dynasty_prestige - adds dynasty prestige
Supported Scopes: dynasty

--------------------

add_dynasty_prestige_level - adds dynasty prestige levels
Supported Scopes: dynasty

--------------------

every_dynasty_member - Iterate through all dynasty members
every_dynasty_member = { limit = { <triggers> } <effects> }
Supported Scopes: dynasty
Supported Targets: character

--------------------

ordered_dynasty_member - Iterate through all dynasty members
ordered_dynasty_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: dynasty
Supported Targets: character

--------------------

random_dynasty_member - Iterate through all dynasty members
random_dynasty_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: dynasty
Supported Targets: character

--------------------

remove_all_dynasty_modifier_instances - Remove all instances of a modifier from a dynasty
remove_all_dynasty_modifier_instances = name
Supported Scopes: dynasty

--------------------

remove_dynasty_modifier - Remove a modifier from a dynasty
remove_dynasty_modifier = name
Supported Scopes: dynasty

--------------------

remove_dynasty_perk - Removes dynasty perk. remove_dynasty_perk = key
Supported Scopes: dynasty

--------------------

add_house_modifier - Add a modifier to a house
add_house_modifier = name
add_house_modifier = { modifier = name days/weeks/months/years = int }
You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
Supported Scopes: dynasty house

--------------------

every_house_member - Iterate through all house members
every_house_member = { limit = { <triggers> } <effects> }
Supported Scopes: dynasty house
Supported Targets: character

--------------------

ordered_house_member - Iterate through all house members
ordered_house_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: dynasty house
Supported Targets: character

--------------------

random_house_member - Iterate through all house members
random_house_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: dynasty house
Supported Targets: character

--------------------

remove_all_house_modifier_instances - Remove all instances of a modifier from a house
remove_all_house_modifier_instances = name
Supported Scopes: dynasty house

--------------------

remove_house_modifier - Remove a modifier from a house
remove_house_modifier = name
Supported Scopes: dynasty house

--------------------

every_faith - Iterate through all faiths within a religion
every_faith = { limit = { <triggers> } <effects> }
Supported Scopes: religion
Supported Targets: faith

--------------------

ordered_faith - Iterate through all faiths within a religion
ordered_faith = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: religion
Supported Targets: faith

--------------------

random_faith - Iterate through all faiths within a religion
random_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: religion
Supported Targets: faith

--------------------

add_scheme_modifier - adds the specified scheme modifier, add_scheme_modifier = { type = X days = Y } (days are optional, the modifier will expire in Y days if specified)
Supported Scopes: scheme

--------------------

add_scheme_progress - Add progress to the scope scheme. (progress is in 0.0 - 100.0 range)
Supported Scopes: scheme

--------------------

end_scheme - Ends a specific scheme and removes it without any other effect
Supported Scopes: scheme

--------------------

every_scheme_agent - Iterate through all agents in the scheme
every_scheme_agent = { limit = { <triggers> } <effects> }
Supported Scopes: scheme
Supported Targets: character

--------------------

expose_scheme - Exposes the scheme to the defender
Supported Scopes: scheme

--------------------

expose_scheme_agent - Exposes the target character as an agent of the current scheme
Supported Scopes: scheme
Supported Targets: character

--------------------

ordered_scheme_agent - Iterate through all agents in the scheme
ordered_scheme_agent = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: scheme
Supported Targets: character

--------------------

random_scheme_agent - Iterate through all agents in the scheme
random_scheme_agent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: scheme
Supported Targets: character

--------------------

remove_scheme_modifier - removes the specified scheme modifier
Supported Scopes: scheme

--------------------

scheme_freeze_days - scheme_freeze_days = X freezes the scheme for X days (0 unfreezes the scheme)
Supported Scopes: scheme

--------------------

add_county_modifier - Add a modifier to a county
add_county_modifier = name
add_county_modifier = { modifier = name days/weeks/months/years = int }
You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
Supported Scopes: landed title

--------------------

change_county_control - Changes the county control of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
Supported Scopes: landed title

--------------------

change_de_jure_drift_progress - Change the progress of de jure drift of a title<drifting_title> = { change_de_jure_drift_progress = {    target = <drift_target_title>    values = <progress_change_value> } }
Supported Scopes: landed title

--------------------

change_development_level - Changes the development level of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
Supported Scopes: landed title

--------------------

change_development_progress - Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
Supported Scopes: landed title

--------------------

change_development_progress_with_overflow - Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it. Will overflow, so adding +100 to a county with 50 progress left will increase the level by 1 and result in 50 progress towards the next level
Supported Scopes: landed title

--------------------

clear_title_laws - remove all title laws from the scoped title. DOES NOT apply law removal costs and effects.
clear_title_laws = yes
Supported Scopes: landed title

--------------------

clear_title_laws_effects - remove all title laws from the scoped title. DOES apply law removal costs and effects.
clear_title_laws_effects = yes
Supported Scopes: landed title

--------------------

copy_title_history - Copy title history from another title
copy_title_history = source_title
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_claimant - Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
every_claimant = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_connected_county - Iterate through all counties connected to this one. Is based on top liege
any/every/whatever_connectec_county = {
	max_naval_distance = 500
	allow_one_county_land_gap = yes
every_connected_county = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_county_province - Iterate through all provinces in a county
every_county_province = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: province

--------------------

every_de_jure_county_holder - Iterate through all characters directly holding counties within this dejure title
every_de_jure_county_holder = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_de_jure_top_liege - Iterate through all top lieges of the counts within this dejure title
every_de_jure_top_liege = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_dejure_vassal_title_holder - Iterate through all the vassal holders of the title
every_dejure_vassal_title_holder = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_election_candidate - Iterate through all characters who are valid candidates in an election for a title
every_election_candidate = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_elector - Iterate through all characters who are valid electors in an election for a title
every_elector = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_in_de_facto_hierarchy - Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
every_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_in_de_jure_hierarchy - Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
every_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_neighboring_county - Iterate through all neighboring counties. Can only be used in county scope
every_neighboring_county = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_this_title_or_de_jure_above - Iterate through this title and all its dejure liege titles
every_this_title_or_de_jure_above = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_heir - Line of succession for the scoped title
every_title_heir = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

every_title_joined_faction - Iterate through all factions joined the scope landed title
every_title_joined_faction = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: faction

--------------------

every_title_to_title_neighboring_and_across_water_barony - Scopes from a title to a neighboring barony (incl. across water, looking trough the de Jure lieges)
every_title_to_title_neighboring_and_across_water_barony = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_and_across_water_county - Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
every_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_and_across_water_duchy - Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
every_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_and_across_water_empire - Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
every_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_and_across_water_kingdom - Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
every_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_barony - Scopes from a title to a neighboring barony (looking trough the de Jure lieges)
every_title_to_title_neighboring_barony = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_county - Scopes from a title to a neighboring county (looking trough the de Jure lieges)
every_title_to_title_neighboring_county = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_duchy - Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
every_title_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_empire - Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
every_title_to_title_neighboring_empire = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

every_title_to_title_neighboring_kingdom - Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
every_title_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

lease_out_to - Lease out the scoped title
lease_out_to = scope:a_holy_order
Supported Scopes: landed title

--------------------

ordered_claimant - Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
ordered_claimant = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_connected_county - Iterate through all counties connected to this one. Is based on top liege
any/every/whatever_connectec_county = {
	max_naval_distance = 500
	allow_one_county_land_gap = yes
ordered_connected_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_county_province - Iterate through all provinces in a county
ordered_county_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: province

--------------------

ordered_de_jure_county_holder - Iterate through all characters directly holding counties within this dejure title
ordered_de_jure_county_holder = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_de_jure_top_liege - Iterate through all top lieges of the counts within this dejure title
ordered_de_jure_top_liege = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_dejure_vassal_title_holder - Iterate through all the vassal holders of the title
ordered_dejure_vassal_title_holder = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_election_candidate - Iterate through all characters who are valid candidates in an election for a title
ordered_election_candidate = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_elector - Iterate through all characters who are valid electors in an election for a title
ordered_elector = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_in_de_facto_hierarchy - Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
ordered_in_de_facto_hierarchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_in_de_jure_hierarchy - Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
ordered_in_de_jure_hierarchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_neighboring_county - Iterate through all neighboring counties. Can only be used in county scope
ordered_neighboring_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_this_title_or_de_jure_above - Iterate through this title and all its dejure liege titles
ordered_this_title_or_de_jure_above = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_heir - Line of succession for the scoped title
ordered_title_heir = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

ordered_title_joined_faction - Iterate through all factions joined the scope landed title
ordered_title_joined_faction = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: faction

--------------------

ordered_title_to_title_neighboring_and_across_water_barony - Scopes from a title to a neighboring barony (incl. across water, looking trough the de Jure lieges)
ordered_title_to_title_neighboring_and_across_water_barony = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_and_across_water_county - Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
ordered_title_to_title_neighboring_and_across_water_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_and_across_water_duchy - Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
ordered_title_to_title_neighboring_and_across_water_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_and_across_water_empire - Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
ordered_title_to_title_neighboring_and_across_water_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_and_across_water_kingdom - Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
ordered_title_to_title_neighboring_and_across_water_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_barony - Scopes from a title to a neighboring barony (looking trough the de Jure lieges)
ordered_title_to_title_neighboring_barony = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_county - Scopes from a title to a neighboring county (looking trough the de Jure lieges)
ordered_title_to_title_neighboring_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_duchy - Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
ordered_title_to_title_neighboring_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_empire - Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
ordered_title_to_title_neighboring_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

ordered_title_to_title_neighboring_kingdom - Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
ordered_title_to_title_neighboring_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_claimant - Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
random_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_connected_county - Iterate through all counties connected to this one. Is based on top liege
any/every/whatever_connectec_county = {
	max_naval_distance = 500
	allow_one_county_land_gap = yes
random_connected_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_county_province - Iterate through all provinces in a county
random_county_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: province

--------------------

random_de_jure_county_holder - Iterate through all characters directly holding counties within this dejure title
random_de_jure_county_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_de_jure_top_liege - Iterate through all top lieges of the counts within this dejure title
random_de_jure_top_liege = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_dejure_vassal_title_holder - Iterate through all the vassal holders of the title
random_dejure_vassal_title_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_election_candidate - Iterate through all characters who are valid candidates in an election for a title
random_election_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_elector - Iterate through all characters who are valid electors in an election for a title
random_elector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_in_de_facto_hierarchy - Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
random_in_de_facto_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_in_de_jure_hierarchy - Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
..._de_jure_vassal_and_below = { continue = { conditions } }
random_in_de_jure_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_neighboring_county - Iterate through all neighboring counties. Can only be used in county scope
random_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_this_title_or_de_jure_above - Iterate through this title and all its dejure liege titles
random_this_title_or_de_jure_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_heir - Line of succession for the scoped title
random_title_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: character

--------------------

random_title_joined_faction - Iterate through all factions joined the scope landed title
random_title_joined_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: faction

--------------------

random_title_to_title_neighboring_and_across_water_barony - Scopes from a title to a neighboring barony (incl. across water, looking trough the de Jure lieges)
random_title_to_title_neighboring_and_across_water_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_and_across_water_county - Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
random_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_and_across_water_duchy - Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
random_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_and_across_water_empire - Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
random_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_and_across_water_kingdom - Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
random_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_barony - Scopes from a title to a neighboring barony (looking trough the de Jure lieges)
random_title_to_title_neighboring_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_county - Scopes from a title to a neighboring county (looking trough the de Jure lieges)
random_title_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_duchy - Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
random_title_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_empire - Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
random_title_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

random_title_to_title_neighboring_kingdom - Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
random_title_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: landed title
Supported Targets: landed title

--------------------

remove_all_county_modifier_instances - Remove all instances of a modifier from a county
remove_all_county_modifier_instances = name
Supported Scopes: landed title

--------------------

remove_county_modifier - Remove a modifier from a county
remove_county_modifier = name
Supported Scopes: landed title

--------------------

reset_title_name - Sets the name and adjective of the scoped title back to being based on its key. Won't cause the prefix to change
reset_title_name = yes
Supported Scopes: landed title

--------------------

reset_title_prefix - Sets the prefix of the scoped title back to being based on its key. Won't cause its adjective or name to change
reset_title_prefix = yes
Supported Scopes: landed title

--------------------

revoke_lease - Revoke the lease of the scoped title
revoke_lease = yes
Supported Scopes: landed title

--------------------

set_always_follows_primary_heir - Sets if the title should always go to the primary heir in partition succession
set_always_follows_primary_heir = yes
Supported Scopes: landed title

--------------------

set_can_be_named_after_dynasty - Sets if the title can be named after it's holder's dynasty. set_can_be_named_after_dynasty_effect = no
Supported Scopes: landed title

--------------------

set_capital_county - Sets the capital county of the title to the target county
set_capital_county = <some county title>
Supported Scopes: landed title
Supported Targets: landed title

--------------------

set_color_from_title - Sets the color of the title to the same as the target title (shifted very slightly to not be identical)
set_color_from_title = <some title>
Supported Scopes: landed title
Supported Targets: landed title

--------------------

set_county_culture - sets the culture of a county
usage:
set_county_culture = english/root.character_culture
Supported Scopes: landed title

--------------------

set_county_faith - Changes what faith a county has
Supported Scopes: landed title

--------------------

set_de_jure_liege_title - Set a new DeJure liege title
set_de_jure_liege_title = new_de_jure_liege
Supported Scopes: landed title
Supported Targets: landed title

--------------------

set_definitive_form - Sets if the title should use a definitive form name (no 'Kingdom of')
set_definitive_form = yes
Supported Scopes: landed title

--------------------

set_delete_on_destroy - Sets if the title should be deleted from the gamestate completely when it is destroyed. set_delete_on_destroy = yes
Supported Scopes: landed title

--------------------

set_destroy_if_invalid_heir - Sets if the title should be destroyed on succession if there's no heir matching its restrictions. set_destroy_if_invalid_heir = yes
Supported Scopes: landed title

--------------------

set_destroy_on_succession - Sets if the title should be destroyed on succession. set_destroy_on_succession = yes
Supported Scopes: landed title

--------------------

set_landless_title - Sets if the title is landless (can be held by rulers with no land)
set_landless_title = yes
Supported Scopes: landed title

--------------------

set_no_automatic_claims - Sets if the title should disallow automatic claims (meaning claims will only be added by script, and by pressed claims being inherited).
set_no_automatic_claims = yes
Supported Scopes: landed title

--------------------

set_title_name - sets the name (localization key) of the scoped title. The adjective will be constructed by adding '_adj' to the localisation key. Won't cause the prefix to change
set_title_name = TEST_NAME_PLEASE_IGNORE
Supported Scopes: landed title

--------------------

set_title_prefix - sets the prefix of the scoped title. Won't cause its name or adjective to change
set_title_prefix = PREFIX_THE
Supported Scopes: landed title

--------------------

title_create_faction - the scoped landed title creates a faction of the specified type against the specified target, title_create_faction = { type = X target = Y }
Supported Scopes: landed title

--------------------

title_join_faction - the landed title in the scope joins the assigned faction
Supported Scopes: landed title

--------------------

title_leave_faction - the title in the scope leaves the assigned faction
Supported Scopes: landed title

--------------------

end_story - Ends a story and executes it's on_end effect, the story can no longer be accessed after this
Supported Scopes: story cycle

--------------------

make_story_owner -  = character_target  makes the character the new owner of the story
Supported Scopes: story cycle
Supported Targets: character

--------------------

add_innovation - Add innovation to a culture. add_innovation = innovation_key
Supported Scopes: culture

--------------------

add_random_innovation - Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }
Supported Scopes: culture

--------------------

get_all_innovations_from - Discover all innovations from the target culture
get_all_innovations_from = <culture>
Supported Scopes: culture
Supported Targets: culture

--------------------

get_random_innovation_from - Get random available innovation from another culture
Supported Scopes: culture

--------------------

remove_innovation - Remove innovation from a culture. remove_innovation = innovation_key
Supported Scopes: culture

--------------------

add_character_flag - adds a character flag
usage:
add_character_flag = X
add_character_flag = { flag = X days/weeks/years = Y }
where X is the name of the flag and Y is a value or value interval "{ min max }"
Supported Scopes: character

--------------------

add_character_modifier - Add a modifier to a character
add_character_modifier = name
add_character_modifier = { modifier = name days/weeks/months/years = int }
You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
Supported Scopes: character

--------------------

add_courtier - Add the target character to the scope character's court
Supported Scopes: character
Supported Targets: character

--------------------

add_diplomacy_lifestyle_perk_points - Adds lifestyle per points to the given character
Supported Scopes: character

--------------------

add_diplomacy_lifestyle_xp - Adds lifestyle XP to the given character
Supported Scopes: character

--------------------

add_dread - adds (or removes) dread to a character
Supported Scopes: character

--------------------

add_gold - adds gold to a character
Supported Scopes: character

--------------------

add_hook - Adds a hook on a character
add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }
Note: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.
Does send a toast to the player if it's involved.
Supported Scopes: character

--------------------

add_hook_no_toast - Adds a hook on a character
add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }
Note: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.
Does NOT send a toast to the player.
Supported Scopes: character

--------------------

add_intrigue_lifestyle_perk_points - Adds lifestyle per points to the given character
Supported Scopes: character

--------------------

add_intrigue_lifestyle_xp - Adds lifestyle XP to the given character
Supported Scopes: character

--------------------

add_joined_faction_discontent - add_joined_faction_discontent = X adds (or subtracts) discontent to the factions the scope character is in
Supported Scopes: character

--------------------

add_knows_of_killer - Adds the right hand side character as knowing of the killer of the scoped object
dead_person = { add_knows_of_killer = root }
Supported Scopes: character
Supported Targets: character

--------------------

add_learning_lifestyle_perk_points - Adds lifestyle per points to the given character
Supported Scopes: character

--------------------

add_learning_lifestyle_xp - Adds lifestyle XP to the given character
Supported Scopes: character

--------------------

add_martial_lifestyle_perk_points - Adds lifestyle per points to the given character
Supported Scopes: character

--------------------

add_martial_lifestyle_xp - Adds lifestyle XP to the given character
Supported Scopes: character

--------------------

add_opinion - Adds a temporary opinion modifier, add_opinion = { modifier = X days/months/years = Y target = Z }
X is a scripted modifier name. Y can be a value or a range "{ A B }" If no timeout are specified, the modifier's scripted default timeout will be used.
Supported Scopes: character

--------------------

add_perk - Adds the perk for this character
Supported Scopes: character

--------------------

add_piety - gives (or takes) piety to a character
Supported Scopes: character

--------------------

add_piety_experience - gives (or takes) piety experience to a character
Supported Scopes: character

--------------------

add_piety_level - increases (or decreases) the piety level of a character
Supported Scopes: character

--------------------

add_piety_no_experience - gives (or takes) piety without experience to a character
Supported Scopes: character

--------------------

add_pressed_claim - gives a pressed claim to a character
Supported Scopes: character
Supported Targets: landed title

--------------------

add_prestige - gives (or takes) prestige to a character
Supported Scopes: character

--------------------

add_prestige_experience - gives (or takes) prestige experience to a character
Supported Scopes: character

--------------------

add_prestige_level - increases (or decreases) the prestige level of a character
Supported Scopes: character

--------------------

add_prestige_no_experience - gives (or takes) prestige without experience to a character
Supported Scopes: character

--------------------

add_realm_law - Adds the given law to the scoped character
Supported Scopes: character

--------------------

add_realm_law_skip_effects - Adds the given law to the scoped character. Skips the cost and the pass effect, and the revoke effects of the current law
Supported Scopes: character

--------------------

add_relation_flag - Adds a flag to an existing relation
add_relation_flag = {
  relation = scripted_relation
  flag = flag_name (declared in the relation's script)
  target = other_character
}
Supported Scopes: character

--------------------

add_scheme_cooldown - Sets a scheme cooldown for the scope character towards = { target=target_character type=scheme_type days/weeks/months/years = duration }
Supported Scopes: character

--------------------

add_secret - Adds a secret
add_secret = { type = X target = Y }
Note that if you create a Secret in the immediate effect, the tooltips for other effects run in that Secret's scope (such as reveal_to) are likely to be displayed incorrectly, or not to be displayed at all. This is due to the game generating the tooltip before it actually has a Secret that exists to work off of.
Test rigorously and use custom tooltips if necessary. Creating a Secret in the immediate and then running effects on it in an event option should produce perfectly normal tooltips.
Supported Scopes: character

--------------------

add_stewardship_lifestyle_perk_points - Adds lifestyle per points to the given character
Supported Scopes: character

--------------------

add_stewardship_lifestyle_xp - Adds lifestyle XP to the given character
Supported Scopes: character

--------------------

add_stress - increases (or decreases) stress of a character
Supported Scopes: character

--------------------

add_targeting_factions_discontent - add_targeting_factions_discontent = X adds (or subtracts) discontent to all the factions that are targeting the scope character
Supported Scopes: character

--------------------

add_to_scheme - Adds a character as an agent to the scheme
Supported Scopes: character

--------------------

add_trait - Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn't eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range)
Supported Scopes: character

--------------------

add_trait_force_tooltip - Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range - a tooltip will be shown but the trait will not be added)
Supported Scopes: character

--------------------

add_truce_both_ways - Sets the both-way truce against the specified character
'character' specifies the target character
'override' says whether it should replace the previous truce even if shorter
'years / months / days' sets the duration of the truce
'result' specifies the result from the scope character's point of view ('white_peace' by default)
'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'
'name' sets a custom description. Dynamic description with the current scope
'war' sets the war that caused the truce, mutually exclusive with 'casus_belli'
add_truce_both_ways = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }
Supported Scopes: character

--------------------

add_truce_one_way - Sets the truce against the specified character
'character' specifies the target character
'override' says whether it should replace the previous truce even if shorter
'years / months / days' sets the duration of the truce
'result' specifies the result from the scope character's point of view ('white_peace' by default)
'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'
'name' sets a custom description. Dynamic description with the current scope
add_truce_one_way = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }
Supported Scopes: character

--------------------

add_tyranny - adds (or removes) tyranny to (or from) a character
Supported Scopes: character

--------------------

add_unpressed_claim - gives an unpressed claim to a character
Supported Scopes: character
Supported Targets: landed title

--------------------

add_visiting_courtier - Add the target character as the scope character's guest
Supported Scopes: character
Supported Targets: character

--------------------

allow_alliance - Allows (previously broken) alliance with the target character
Supported Scopes: character
Supported Targets: character

--------------------

allow_in_scheme - Allow the character to join the scheme as an agent
Supported Scopes: character

--------------------

apply_ai_vassal_obligation_liege_most_desired - Apply the new level for the most desired AI obligation level the liege in the contract wants
Supported Scopes: character

--------------------

apply_ai_vassal_obligation_vassal_most_desired - Apply the new level for the most desired AI obligation level the vassal in the contract wants
Supported Scopes: character

--------------------

assign_council_task - Assigns the target character to the council task
assign_council_task = {
    council_task = council_task_scope
    target = character_taking_the_position    fire_on_actions = [yes]
}
Supported Scopes: character

--------------------

assign_councillor_type - Assigns the target character to the first available council position of the type available. { type = council_position_type_key target = character_taking_the_position fire_on_actions = [yes] }
Supported Scopes: character

--------------------

banish - The character gets banished.
Supported Scopes: character

--------------------

becomes_independent - becomes and independent ruler. becomes_independent = { change = 'previously created title_and_vassal_change'
Supported Scopes: character

--------------------

break_alliance - Breaks the alliance with the target character
Supported Scopes: character
Supported Targets: character

--------------------

cancel_truce_both_ways - Ends the truce against the specified character, and theirs against the scoped character. cancel_truce_both_ways = scope:character
Supported Scopes: character
Supported Targets: character

--------------------

cancel_truce_one_way - Ends the truce against the specified character. cancel_truce_one_way = scope:character
Supported Scopes: character
Supported Targets: character

--------------------

change_age - Changes the character's age by the given amount. Sets age to 0 if it'd end up below 0. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command
   Usage: change_age = script value
Supported Scopes: character

--------------------

change_current_weight - Change the current weight of the scoped character
change_current_weight = 20
Supported Scopes: character

--------------------

change_first_name - Change the first name of a character
change_first_name = <localization_key>
change_first_name = scope:name/var:name # containing a flag with a localization key
change_first_name = { template_character = scope:character } # copy name from the template character
Supported Scopes: character

--------------------

change_government - changes the government of a character
Supported Scopes: character

--------------------

change_liege -  = { liege = 'Character that should become the new liege' change = 'previously created title_and_vassal_change', adds a liege change
Supported Scopes: character

--------------------

change_prison_type - Changes the charater's prison type. Scoped character is the prisoner. Accepts any static modifier (see also improson effect).
change_prison_type = house_arrest
Supported Scopes: character

--------------------

change_target_weight - Change the target weight of the scoped character
change_target_weight = 20
Supported Scopes: character

--------------------

change_trait_rank - Changes the trait rank = { trait = trait_group rank = change max = maximum new rank }
Supported Scopes: character

--------------------

clear_forced_vote - Clears forced voting
clear_forced_vote = yes
Supported Scopes: character

--------------------

consume_banish_reasons - 'Consume' all banish reasons that the scoped character has on the target character. Until they get a new reason, they cannot banish the target again.
Supported Scopes: character
Supported Targets: character

--------------------

consume_divorce_reasons - 'Consume' all divorce reason that the scoped character has on the target character. Until they get a new reason, they cannot divorce the target again.
Supported Scopes: character
Supported Targets: character

--------------------

consume_execute_reasons - 'Consume' all execute reasons that the scoped character has on the target character. Until they get a new reason, they cannot execute the target again.
Supported Scopes: character
Supported Targets: character

--------------------

consume_imprisonment_reasons - 'Consume' all imprisonment reasons that the scoped character has on the target character. Until they get a new reason, they cannot imprison the target again.
Supported Scopes: character
Supported Targets: character

--------------------

consume_revoke_title_reason - 'Consume' 1 revoke title reason that the scoped character has on the target character.
Supported Scopes: character
Supported Targets: character

--------------------

copy_inheritable_appearance_from - copies the inheritable appearance attributes (inheritable genes in the character's DNA string) from the target character to the scoped character
Supported Scopes: character
Supported Targets: character

--------------------

copy_localized_text - Copies a piece of localized text from the target character for the given key.
copy_localized_text = { key = key target = character }
Supported Scopes: character

--------------------

create_alliance - Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not.
create_alliance = {
	target = scope
	allied_through_owner = scope
	allied_through_target = scope
}
OR as a short hand use just the target to use the owner and target as the allied through characters
create_alliance = scope
Supported Scopes: character

--------------------

create_cadet_branch - The scope character creates a cadet branch of the house he is in [yes|no]
Supported Scopes: character

--------------------

create_faction - the scoped character creates a faction of the specified type against the specified target, create_faction = { type = X target = Y }
Supported Scopes: character

--------------------

create_story - creates and initializes a story cycle with the current character as owner
create_story = story_type
create_story = {
	type = story_type
	save_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story}
Supported Scopes: character

--------------------

death - kills a character, death = { killer = X death_reason = Y }, where X is a character and Y is one of the death reason keys. Or death = natural which will pick a natural death reason to kill the character from.
Supported Scopes: character

--------------------

depose - The character gets deposed.
Supported Scopes: character

--------------------

destroy_title - Destroys a title
Supported Scopes: character
Supported Targets: landed title

--------------------

end_pregnancy - end a pregnancy
Supported Scopes: character

--------------------

every_alert_creatable_title - Iterate through all titles that can be created by the character. (only for alerts)
every_alert_creatable_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_alert_usurpable_title - Iterate through all titles that can be usurped by the character. (only for alerts)
every_alert_usurpable_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_ally - Iterate through all allies
every_ally = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_ancestor - Iterate through all the ancestors of the scope character up to 5 generations
every_ancestor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_army - Iterate through all armies
every_army = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: army

--------------------

every_character_to_title_neighboring_and_across_water_county - Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
every_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_and_across_water_duchy - Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
every_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_and_across_water_empire - Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
every_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_and_across_water_kingdom - Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
every_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_county - Scopes from a character to a neighboring county (looking trough the de Jure lieges)
every_character_to_title_neighboring_county = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_duchy - Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
every_character_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_empire - Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
every_character_to_title_neighboring_empire = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_to_title_neighboring_kingdom - Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
every_character_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_character_war - Wars of the scoped character
every_character_war = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: war

--------------------

every_child - Iterate through all children
every_child = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_claim - Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all
every_claim = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_close_family_member - Iterate through all the close family [father, mother, siblings, children, grandparents]
every_close_family_member = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_close_or_extended_family_member - Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]
every_close_or_extended_family_member = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_concubine - Iterate through all concubines
every_concubine = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_consort - Iterate through all consorts (concubines and spouses)
every_consort = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_councillor - Iterate through all councillors
every_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_courtier - Iterate through all courtiers
every_courtier = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_courtier_away - Iterate through all courtiers that are away
every_courtier_away = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_courtier_or_guest - Iterate through all courtiers and guests (pool and foreign court guests)
every_courtier_or_guest = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_de_jure_claim - Iterate through all de jure claims for a character
every_de_jure_claim = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_diplomacy_councillor - Iterate through all diplomacy-based councillors
every_diplomacy_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_directly_owned_province - Iterate through all directly owned provinces
every_directly_owned_province = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

every_election_title - Iterate through all titles the scoped character can vote on
every_election_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_extended_family_member - Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
every_extended_family_member = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_foreign_court_guest - Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
every_foreign_court_guest = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_former_concubine - Iterate through all former concubines. Not persisted past death
every_former_concubine = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_former_concubinist - Iterate through all former concubinists. Not persisted past death
every_former_concubinist = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_former_spouse - Iterate through all former spouses
every_former_spouse = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_general_councillor - Iterate through all councillors that are not related to a skill
every_general_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_heir - Heirs of the scoped character
every_heir = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_heir_title - Iterate through all landed titles character is heir to
every_heir_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_heir_to_title - Iterate through all titles the scoped character is heir to
every_heir_to_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_held_title - Iterate through all held landed titles
every_held_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_hired_mercenary - Iterate through all hired mercenary companies
every_hired_mercenary = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: mercenary company

--------------------

every_hooked_character - Iterate through all characters this character has a hook on
every_hooked_character = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_hostile_raider - Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
every_hostile_raider = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_intrigue_councillor - Iterate through all intrigue-based councillors
every_intrigue_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_knight - Iterate through all knights
every_knight = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_known_secret - Iterate through all secrets known by the character
every_known_secret = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

every_learning_councillor - Iterate through all learning-based councillors
every_learning_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_liege_or_above - Iterate through all lieges above a character (skipping the character themselves)
every_liege_or_above = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_martial_councillor - Iterate through all martial-based councillors
every_martial_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_neighboring_and_across_water_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
every_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_neighboring_and_across_water_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
every_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_neighboring_and_across_water_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
every_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_neighboring_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
every_neighboring_realm_same_rank_owner = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_neighboring_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
every_neighboring_top_liege_realm = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_neighboring_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
every_neighboring_top_liege_realm_owner = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_owned_story - Iterate through all owned stories for a character
every_owned_story = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: story cycle

--------------------

every_parent - Iterate through all (both) parents
every_parent = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_patroned_holy_order - Iterate through all holy orders that the scoped character is a patron of
every_patroned_holy_order = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: holy order

--------------------

every_pinned_character - Iterate through characters this player has pinned
every_pinned_character = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_pinning_character - Iterate through characters whose player has this character pinned
every_pinning_character = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_player_heir - Iterate through player heirs, capped at the first 10
every_player_heir = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_pool_guest - Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
every_pool_guest = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_potential_marriage_option - Iterate through all potential selectable marriage or betrohed options
every_potential_marriage_option = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_pretender_title - Iterate through all landed titles character is pretender to
every_pretender_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_primary_war_enemy - Iterate through all primary war enemies
every_primary_war_enemy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_prisoner - Iterate through all prisoners
every_prisoner = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_prowess_councillor - Iterate through all prowess-based councillors
every_prowess_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_raid_target - Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
every_raid_target = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_realm_county - Iterate through all counties in the realm. Based on top liege

every_realm_county = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_realm_de_jure_duchy - Iterate through all de jure duchies that have at least one county in the realm. Based on top liege

every_realm_de_jure_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_realm_de_jure_empire - Iterate through all de jure empire that have at least one county in the realm. Based on top liege

every_realm_de_jure_empire = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_realm_de_jure_kingdom - Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege

every_realm_de_jure_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_realm_province - Iterate through all realm provinces of a character
every_realm_province = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

every_relation - Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once
every_relation = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_scheme - Iterate through all schemes owned by the character
every_scheme = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

every_secret - Iterate through all secrets of the character
every_secret = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

every_sibling - Iterate through all siblings
every_sibling = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_spouse - Iterate through all spouses
every_spouse = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_spouse_candidate - Iterate through all the spouse candidates of a character. WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
every_spouse_candidate = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_stewardship_councillor - Iterate through all stewardship-based councillors
every_stewardship_councillor = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_sub_realm_barony - Iterate through all baronies in sub-realm
every_sub_realm_barony = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_sub_realm_county - Iterate through all counties in sub-realm
every_sub_realm_county = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_sub_realm_duchy - Iterate through all duchies in sub-realm
every_sub_realm_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_sub_realm_empire - Iterate through all empires in sub-realm
every_sub_realm_empire = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_sub_realm_kingdom - Iterate through all kingdoms in sub-realm
every_sub_realm_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_sub_realm_title - Iterate through all titles in sub-realm
every_sub_realm_title = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

every_targeting_faction - Iterate through all factions targeting the scope character
every_targeting_faction = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: faction

--------------------

every_targeting_scheme - Iterate through all schemes targeting the character
every_targeting_scheme = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

every_targeting_secret - Iterate through all secrets that target the specified scope
every_targeting_secret = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

every_traveling_family_member - Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
every_traveling_family_member = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_truce_holder - Iterate through all characters that have a truce on this character
every_truce_holder = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_truce_target - Iterate through all characters this character has a truce on
every_truce_target = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_unspent_known_secret - Iterate through all unspent secrets known by the character
every_unspent_known_secret = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

every_vassal - Iterate through all DIRECT vassals
every_vassal = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_vassal_or_below - Iterate through ALL vassals, not just direct vassals
every_vassal_or_below = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_war_ally - Iterate through all direct war allies
every_war_ally = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_war_enemy - Iterate through all direct war enemies
every_war_enemy = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

execute_decision - Execute the specified decision for the scoped character
Supported Scopes: character

--------------------

finish_council_task - The councillor finish the current assigned task successfully.
Supported Scopes: character

--------------------

fire_councillor - The scope character fires the target character form teh council.
Supported Scopes: character
Supported Targets: character

--------------------

forbid_from_scheme - Forbid the scope character from joining the target scheme as an agent (and kick the character out if already in the scheme)
Supported Scopes: character

--------------------

force_add_to_scheme - Adds a character as an agent to the scheme and forces them to stay
{
    scheme = target_Scheme
    days/months/years = duration
}
Supported Scopes: character

--------------------

force_character_skill_recalculation - Forces a character's skills to be recalculated immediately, bypassing the wait for the daily tick.
NOTE: Only use this when *absolutely* necessary, as it will impact performance negatively if misused
   Usage: force_character_skill_recalculation = yes/no
Supported Scopes: character

--------------------

force_vote_as - Forces the character to vote the same as the target
force_vote_as = { target = someone days/months/years = x }
Supported Scopes: character

--------------------

get_title - gives a title to a character
Supported Scopes: character
Supported Targets: landed title

--------------------

give_nickname - Give a nickname to this character
Supported Scopes: character

--------------------

imprison - Imprisons the target character as this character's prisoner, imprison = { target = X reason = Y type = Z }, where X is a character, Y is a flag, Z is a static modifier
Supported Scopes: character

--------------------

join_faction - the character in the scope joins the assigned faction
Supported Scopes: character

--------------------

join_faction_forced - the character in the scope is forced to join a faction by a character for a defined time,
join_faction_forced = {
    faction = X
    forced_by = Y
    days/months/years = duration
}
Supported Scopes: character

--------------------

join_faction_skip_check - the character in the scope joins the assigned faction skiping the can_character_join trigger
Supported Scopes: character

--------------------

leave_faction - the charcter in the scope leaves the assigned faction
Supported Scopes: character

--------------------

make_claim_strong - makes a claim strong (character adds the claim if not having it already)
Supported Scopes: character
Supported Targets: landed title

--------------------

make_claim_weak - makes a claim weak (character adds the claim if not having it already)
Supported Scopes: character
Supported Targets: landed title

--------------------

make_concubine - Makes the target character a concubine of the scope character, the target should not be imprisoned
Supported Scopes: character
Supported Targets: character

--------------------

make_pregnant - makes a character pregnant 
 father= 'the real father'
 number_of_children= X
 known_bastard=yes/no
Supported Scopes: character

--------------------

make_pregnant_no_checks - makes a character pregnant. Doesn't error on things like celibacy 
 father= 'the real father'
 number_of_children= X
 known_bastard=yes/no
Supported Scopes: character

--------------------

make_trait_active - Activates an inactive trait. Tooltip will not be shown if the character cannot have the trait.
Supported Scopes: character

--------------------

make_trait_active_force_tooltip - Activates an inactive trait. Tooltip will be shown even if the character cannot have the trait.
Supported Scopes: character

--------------------

make_trait_inactive - Makes a current trait of a character inactive. Tooltip will not be shown if the character doesn't have the trait.
Supported Scopes: character

--------------------

make_trait_inactive_force_tooltip - Makes a current trait of a character inactive. Tooltip will be shown even if the character doesn't have the trait.
Supported Scopes: character

--------------------

make_unprunable - The scope character will no longer be prunable after their death. Use with care, as this will make everyone related to them unprunable too. So you should only use this if someone absolutely *needs* to stick around several years after their death. Example: make_unprunable = yes
Supported Scopes: character

--------------------

marry - Marries the scoped character to the target character
marry = target
Supported Scopes: character
Supported Targets: character

--------------------

marry_matrilineal - Marries the scoped character to the target character matrilineally
marry_matrilineal = target
Supported Scopes: character
Supported Targets: character

--------------------

move_to_pool - The scoped character (courtier or guest) leaves their current court and moves into the pool
scope:guest = { move_to_pool = yes }
Supported Scopes: character

--------------------

move_to_pool_at - The scoped character (courtier/guest/pool character) leaves their current court (if any) and moves into the pool of the specified province
scope:guest = { move_to_pool_at = scope:some_province }
Supported Scopes: character
Supported Targets: province

--------------------

ordered_alert_creatable_title - Iterate through all titles that can be created by the character. (only for alerts)
ordered_alert_creatable_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_alert_usurpable_title - Iterate through all titles that can be usurped by the character. (only for alerts)
ordered_alert_usurpable_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_ally - Iterate through all allies
ordered_ally = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_ancestor - Iterate through all the ancestors of the scope character up to 5 generations
ordered_ancestor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_army - Iterate through all armies
ordered_army = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: army

--------------------

ordered_character_to_title_neighboring_and_across_water_county - Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
ordered_character_to_title_neighboring_and_across_water_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_and_across_water_duchy - Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
ordered_character_to_title_neighboring_and_across_water_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_and_across_water_empire - Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
ordered_character_to_title_neighboring_and_across_water_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_and_across_water_kingdom - Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
ordered_character_to_title_neighboring_and_across_water_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_county - Scopes from a character to a neighboring county (looking trough the de Jure lieges)
ordered_character_to_title_neighboring_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_duchy - Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
ordered_character_to_title_neighboring_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_empire - Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
ordered_character_to_title_neighboring_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_to_title_neighboring_kingdom - Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
ordered_character_to_title_neighboring_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_character_war - Wars of the scoped character
ordered_character_war = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: war

--------------------

ordered_child - Iterate through all children
ordered_child = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_claim - Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all
ordered_claim = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_close_family_member - Iterate through all the close family [father, mother, siblings, children, grandparents]
ordered_close_family_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_close_or_extended_family_member - Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]
ordered_close_or_extended_family_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_concubine - Iterate through all concubines
ordered_concubine = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_consort - Iterate through all consorts (concubines and spouses)
ordered_consort = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_councillor - Iterate through all councillors
ordered_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_courtier - Iterate through all courtiers
ordered_courtier = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_courtier_away - Iterate through all courtiers that are away
ordered_courtier_away = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_courtier_or_guest - Iterate through all courtiers and guests (pool and foreign court guests)
ordered_courtier_or_guest = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_de_jure_claim - Iterate through all de jure claims for a character
ordered_de_jure_claim = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_diplomacy_councillor - Iterate through all diplomacy-based councillors
ordered_diplomacy_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_directly_owned_province - Iterate through all directly owned provinces
ordered_directly_owned_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: province

--------------------

ordered_election_title - Iterate through all titles the scoped character can vote on
ordered_election_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_extended_family_member - Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
ordered_extended_family_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_foreign_court_guest - Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
ordered_foreign_court_guest = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_former_concubine - Iterate through all former concubines. Not persisted past death
ordered_former_concubine = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_former_concubinist - Iterate through all former concubinists. Not persisted past death
ordered_former_concubinist = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_former_spouse - Iterate through all former spouses
ordered_former_spouse = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_general_councillor - Iterate through all councillors that are not related to a skill
ordered_general_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_heir - Heirs of the scoped character
ordered_heir = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_heir_title - Iterate through all landed titles character is heir to
ordered_heir_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_heir_to_title - Iterate through all titles the scoped character is heir to
ordered_heir_to_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_held_title - Iterate through all held landed titles
ordered_held_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_hired_mercenary - Iterate through all hired mercenary companies
ordered_hired_mercenary = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: mercenary company

--------------------

ordered_hooked_character - Iterate through all characters this character has a hook on
ordered_hooked_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_hostile_raider - Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
ordered_hostile_raider = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_intrigue_councillor - Iterate through all intrigue-based councillors
ordered_intrigue_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_knight - Iterate through all knights
ordered_knight = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_known_secret - Iterate through all secrets known by the character
ordered_known_secret = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

ordered_learning_councillor - Iterate through all learning-based councillors
ordered_learning_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_liege_or_above - Iterate through all lieges above a character (skipping the character themselves)
ordered_liege_or_above = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_martial_councillor - Iterate through all martial-based councillors
ordered_martial_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_neighboring_and_across_water_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
ordered_neighboring_and_across_water_realm_same_rank_owner = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_neighboring_and_across_water_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
ordered_neighboring_and_across_water_top_liege_realm = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_neighboring_and_across_water_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
ordered_neighboring_and_across_water_top_liege_realm_owner = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_neighboring_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
ordered_neighboring_realm_same_rank_owner = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_neighboring_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
ordered_neighboring_top_liege_realm = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_neighboring_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
ordered_neighboring_top_liege_realm_owner = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_owned_story - Iterate through all owned stories for a character
ordered_owned_story = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: story cycle

--------------------

ordered_parent - Iterate through all (both) parents
ordered_parent = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_patroned_holy_order - Iterate through all holy orders that the scoped character is a patron of
ordered_patroned_holy_order = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: holy order

--------------------

ordered_pinned_character - Iterate through characters this player has pinned
ordered_pinned_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_pinning_character - Iterate through characters whose player has this character pinned
ordered_pinning_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_player_heir - Iterate through player heirs, capped at the first 10
ordered_player_heir = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_pool_guest - Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
ordered_pool_guest = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_potential_marriage_option - Iterate through all potential selectable marriage or betrohed options
ordered_potential_marriage_option = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_pretender_title - Iterate through all landed titles character is pretender to
ordered_pretender_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_primary_war_enemy - Iterate through all primary war enemies
ordered_primary_war_enemy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_prisoner - Iterate through all prisoners
ordered_prisoner = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_prowess_councillor - Iterate through all prowess-based councillors
ordered_prowess_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_raid_target - Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
ordered_raid_target = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_realm_county - Iterate through all counties in the realm. Based on top liege

ordered_realm_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_realm_de_jure_duchy - Iterate through all de jure duchies that have at least one county in the realm. Based on top liege

ordered_realm_de_jure_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_realm_de_jure_empire - Iterate through all de jure empire that have at least one county in the realm. Based on top liege

ordered_realm_de_jure_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_realm_de_jure_kingdom - Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege

ordered_realm_de_jure_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_realm_province - Iterate through all realm provinces of a character
ordered_realm_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: province

--------------------

ordered_relation - Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once
ordered_relation = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_scheme - Iterate through all schemes owned by the character
ordered_scheme = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

ordered_secret - Iterate through all secrets of the character
ordered_secret = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

ordered_sibling - Iterate through all siblings
ordered_sibling = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_spouse - Iterate through all spouses
ordered_spouse = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_spouse_candidate - Iterate through all the spouse candidates of a character. WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
ordered_spouse_candidate = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_stewardship_councillor - Iterate through all stewardship-based councillors
ordered_stewardship_councillor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_sub_realm_barony - Iterate through all baronies in sub-realm
ordered_sub_realm_barony = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_sub_realm_county - Iterate through all counties in sub-realm
ordered_sub_realm_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_sub_realm_duchy - Iterate through all duchies in sub-realm
ordered_sub_realm_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_sub_realm_empire - Iterate through all empires in sub-realm
ordered_sub_realm_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_sub_realm_kingdom - Iterate through all kingdoms in sub-realm
ordered_sub_realm_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_sub_realm_title - Iterate through all titles in sub-realm
ordered_sub_realm_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

ordered_targeting_faction - Iterate through all factions targeting the scope character
ordered_targeting_faction = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: faction

--------------------

ordered_targeting_scheme - Iterate through all schemes targeting the character
ordered_targeting_scheme = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

ordered_targeting_secret - Iterate through all secrets that target the specified scope
ordered_targeting_secret = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

ordered_traveling_family_member - Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
ordered_traveling_family_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_truce_holder - Iterate through all characters that have a truce on this character
ordered_truce_holder = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_truce_target - Iterate through all characters this character has a truce on
ordered_truce_target = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_unspent_known_secret - Iterate through all unspent secrets known by the character
ordered_unspent_known_secret = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

ordered_vassal - Iterate through all DIRECT vassals
ordered_vassal = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_vassal_or_below - Iterate through ALL vassals, not just direct vassals
ordered_vassal_or_below = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_war_ally - Iterate through all direct war allies
ordered_war_ally = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_war_enemy - Iterate through all direct war enemies
ordered_war_enemy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

pay_long_term_gold - the scope character pays gold to the target character, pay_gold = { target = X gold = Y } (AI budget category long term)
Supported Scopes: character

--------------------

pay_long_term_income - the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget long term)
Supported Scopes: character

--------------------

pay_short_term_gold - the scope character pays gold to the target character, pay_gold = { target = X gold = Y } (AI budget category short term)
Supported Scopes: character

--------------------

pay_short_term_income - the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget short term)
Supported Scopes: character

--------------------

play_music_cue - Plays the specified music cue.
Supported Scopes: character

--------------------

random_alert_creatable_title - Iterate through all titles that can be created by the character. (only for alerts)
random_alert_creatable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_alert_usurpable_title - Iterate through all titles that can be usurped by the character. (only for alerts)
random_alert_usurpable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_ally - Iterate through all allies
random_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_ancestor - Iterate through all the ancestors of the scope character up to 5 generations
random_ancestor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_army - Iterate through all armies
random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: army

--------------------

random_character_to_title_neighboring_and_across_water_county - Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
random_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_and_across_water_duchy - Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
random_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_and_across_water_empire - Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
random_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_and_across_water_kingdom - Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
random_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_county - Scopes from a character to a neighboring county (looking trough the de Jure lieges)
random_character_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_duchy - Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
random_character_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_empire - Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
random_character_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_to_title_neighboring_kingdom - Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
random_character_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_character_war - Wars of the scoped character
random_character_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: war

--------------------

random_child - Iterate through all children
random_child = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_claim - Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all
random_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_close_family_member - Iterate through all the close family [father, mother, siblings, children, grandparents]
random_close_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_close_or_extended_family_member - Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]
random_close_or_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_concubine - Iterate through all concubines
random_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_consort - Iterate through all consorts (concubines and spouses)
random_consort = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_councillor - Iterate through all councillors
random_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_courtier - Iterate through all courtiers
random_courtier = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_courtier_away - Iterate through all courtiers that are away
random_courtier_away = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_courtier_or_guest - Iterate through all courtiers and guests (pool and foreign court guests)
random_courtier_or_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_de_jure_claim - Iterate through all de jure claims for a character
random_de_jure_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_diplomacy_councillor - Iterate through all diplomacy-based councillors
random_diplomacy_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_directly_owned_province - Iterate through all directly owned provinces
random_directly_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

random_election_title - Iterate through all titles the scoped character can vote on
random_election_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_extended_family_member - Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
random_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_foreign_court_guest - Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
random_foreign_court_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_former_concubine - Iterate through all former concubines. Not persisted past death
random_former_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_former_concubinist - Iterate through all former concubinists. Not persisted past death
random_former_concubinist = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_former_spouse - Iterate through all former spouses
random_former_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_general_councillor - Iterate through all councillors that are not related to a skill
random_general_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_heir - Heirs of the scoped character
random_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_heir_title - Iterate through all landed titles character is heir to
random_heir_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_heir_to_title - Iterate through all titles the scoped character is heir to
random_heir_to_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_held_title - Iterate through all held landed titles
random_held_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_hired_mercenary - Iterate through all hired mercenary companies
random_hired_mercenary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: mercenary company

--------------------

random_hooked_character - Iterate through all characters this character has a hook on
random_hooked_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_hostile_raider - Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
random_hostile_raider = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_intrigue_councillor - Iterate through all intrigue-based councillors
random_intrigue_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_knight - Iterate through all knights
random_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_known_secret - Iterate through all secrets known by the character
random_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

random_learning_councillor - Iterate through all learning-based councillors
random_learning_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_liege_or_above - Iterate through all lieges above a character (skipping the character themselves)
random_liege_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_martial_councillor - Iterate through all martial-based councillors
random_martial_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_neighboring_and_across_water_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
random_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_neighboring_and_across_water_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
random_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_neighboring_and_across_water_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
random_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_neighboring_realm_same_rank_owner - A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
random_neighboring_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_neighboring_top_liege_realm - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
random_neighboring_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_neighboring_top_liege_realm_owner - A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
random_neighboring_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_owned_story - Iterate through all owned stories for a character
random_owned_story = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: story cycle

--------------------

random_parent - Iterate through all (both) parents
random_parent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_patroned_holy_order - Iterate through all holy orders that the scoped character is a patron of
random_patroned_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: holy order

--------------------

random_pinned_character - Iterate through characters this player has pinned
random_pinned_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_pinning_character - Iterate through characters whose player has this character pinned
random_pinning_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_player_heir - Iterate through player heirs, capped at the first 10
random_player_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_pool_guest - Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
random_pool_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_potential_marriage_option - Iterate through all potential selectable marriage or betrohed options
random_potential_marriage_option = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_pretender_title - Iterate through all landed titles character is pretender to
random_pretender_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_primary_war_enemy - Iterate through all primary war enemies
random_primary_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_prisoner - Iterate through all prisoners
random_prisoner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_prowess_councillor - Iterate through all prowess-based councillors
random_prowess_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_raid_target - Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
random_raid_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_realm_county - Iterate through all counties in the realm. Based on top liege

random_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_realm_de_jure_duchy - Iterate through all de jure duchies that have at least one county in the realm. Based on top liege

random_realm_de_jure_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_realm_de_jure_empire - Iterate through all de jure empire that have at least one county in the realm. Based on top liege

random_realm_de_jure_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_realm_de_jure_kingdom - Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege

random_realm_de_jure_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_realm_province - Iterate through all realm provinces of a character
random_realm_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

random_relation - Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once
random_relation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_scheme - Iterate through all schemes owned by the character
random_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

random_secret - Iterate through all secrets of the character
random_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

random_sibling - Iterate through all siblings
random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_spouse - Iterate through all spouses
random_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_spouse_candidate - Iterate through all the spouse candidates of a character. WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
random_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_stewardship_councillor - Iterate through all stewardship-based councillors
random_stewardship_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_sub_realm_barony - Iterate through all baronies in sub-realm
random_sub_realm_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_sub_realm_county - Iterate through all counties in sub-realm
random_sub_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_sub_realm_duchy - Iterate through all duchies in sub-realm
random_sub_realm_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_sub_realm_empire - Iterate through all empires in sub-realm
random_sub_realm_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_sub_realm_kingdom - Iterate through all kingdoms in sub-realm
random_sub_realm_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_sub_realm_title - Iterate through all titles in sub-realm
random_sub_realm_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: landed title

--------------------

random_targeting_faction - Iterate through all factions targeting the scope character
random_targeting_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: faction

--------------------

random_targeting_scheme - Iterate through all schemes targeting the character
random_targeting_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: scheme

--------------------

random_targeting_secret - Iterate through all secrets that target the specified scope
random_targeting_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

random_traveling_family_member - Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
random_traveling_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_truce_holder - Iterate through all characters that have a truce on this character
random_truce_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_truce_target - Iterate through all characters this character has a truce on
random_truce_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_unspent_known_secret - Iterate through all unspent secrets known by the character
random_unspent_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: secret

--------------------

random_vassal - Iterate through all DIRECT vassals
random_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_vassal_or_below - Iterate through ALL vassals, not just direct vassals
random_vassal_or_below = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_war_ally - Iterate through all direct war allies
random_war_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_war_enemy - Iterate through all direct war enemies
random_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

recalculate_scripted_relation - Recalculates the effect of a scripted relation
recalculate_scripted_relation= friend
Supported Scopes: character

--------------------

recruit_courtier - Recruits the target to become a courtier. Example scope:liege = { recruit_courtier = scope:new_courtier }
Supported Scopes: character
Supported Targets: character

--------------------

refund_all_perks - Refunds all perks of the character. Example: refund_all_perks = yes
Supported Scopes: character

--------------------

refund_perks - Refunds all perks of the RHS lifestyle. Example: refund_perks = intrigue_lifestyle
Supported Scopes: character

--------------------

release_from_prison - releases the character from the prison, imprison = X, where X is a boolean value
Supported Scopes: character

--------------------

remove_all_character_modifier_instances - Remove all instances of a modifier from a character
remove_all_character_modifier_instances = name
Supported Scopes: character

--------------------

remove_character_flag - removes a character flag
Supported Scopes: character

--------------------

remove_character_modifier - Remove a modifier from a character
remove_character_modifier = name
Supported Scopes: character

--------------------

remove_claim - removes an explicit (not from a living parent/grand parent) claim
Supported Scopes: character
Supported Targets: landed title

--------------------

remove_concubine - Removes the target character as a concubine of the scope character
Supported Scopes: character
Supported Targets: character

--------------------

remove_courtier_or_guest - Removes the target character (guest or courtier) from the scope character's court
scope:host = { remove_courtier_or_guest = scope:guest } # move to pool, staying in same province
scope:host = {
	remove_courtier_or_guest = {
		character = scope:guest
		new_location = scope:some_province # optionally specify a new location
	}
}
Supported Scopes: character
Supported Targets: character

--------------------

remove_decision_cooldown - Remove the cooldown on taking a decision for the scoped character
remove_decision_cooldown = decision_name
Supported Scopes: character

--------------------

remove_hook - Removes a hook on a character, remove_hook = { target = X, type = Y }, if type is specified, the hook will only be removed if it is of that type
Supported Scopes: character

--------------------

remove_interaction_cooldown - Remove the cooldown on using an interaction for the scoped character
remove_interaction_cooldown = interaction_name
Supported Scopes: character

--------------------

remove_interaction_cooldown_against - Remove the cooldown on using an interaction against the target character for the scoped character
remove_interaction_cooldown_against = { interaction = interaction_name target = character }
Supported Scopes: character

--------------------

remove_localized_text - Removes a piece of localized text from being stored on the character with a given key, you should do this whenever you are done with the custom text so as to not bloat saves
remove_localized_text = key
Supported Scopes: character

--------------------

remove_long_term_gold - removes gold from a character (AI's long term budget)
Supported Scopes: character

--------------------

remove_nickname - Removes any nickname from the current character [yes|no]
Supported Scopes: character

--------------------

remove_opinion - Removes a temporary opinion modifier, remove_opinion = { target = X modifier = Y single = Z (no by default) } where X is a character, Y is the opinion modifier, Z tells whether to remove all instances of the modifier or just one
Supported Scopes: character

--------------------

remove_perk - Remove the perk for this character
Supported Scopes: character

--------------------

remove_realm_law - Removes the given law from the scoped character. This will leave the law group empty, so only do this if you're getting rid of a law group
Supported Scopes: character

--------------------

remove_relation_best_friend - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_bully - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_court_physician - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_crush - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_flag - Removed a flag from an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation
Supported Scopes: character

--------------------

remove_relation_friend - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_guardian - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_intrigue_mentor - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_intrigue_student - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_lover - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_mentor - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_nemesis - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_oaf - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_potential_friend - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_potential_lover - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_potential_rival - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_rival - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_soldier_friend - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_soulmate - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_student - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_victim - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_relation_ward - Removes scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

remove_scheme_cooldown_against - Remove the cooldown on using a scheme against the target character for the scoped character
remove_scheme_cooldown_against = { scheme = scheme_name target = character }
Supported Scopes: character

--------------------

remove_short_term_gold - removes gold from a character (AI's short term budget)
Supported Scopes: character

--------------------

remove_trait - Removes a trait from a character. Tooltip will not be shown if the character doesn't have the trait.
Supported Scopes: character

--------------------

remove_trait_force_tooltip - Removes a trait from a character. Tooltip will be shown even if the character doesn't have the trait.
Supported Scopes: character

--------------------

reset_beneficiary - The target character stops having a beneficiary. reset_beneficiary = yes
Supported Scopes: character

--------------------

return_to_court - Returns the scope character to the employers court.
Supported Scopes: character

--------------------

reverse_add_opinion - Adds a temporary reverse opinion modifier, reverse_add_opinion = { modifier = X days/months/years = Y target = Z }
X is a scripted modifier name. Y can be a value or a range "{ A B }" If no timeout are specified, the modifier's scripted default timeout will be used.
Supported Scopes: character

--------------------

scriptedtests_recalculate_character_modifier - Recalculates the modifier of the scoped character
Supported Scopes: character

--------------------

scriptedtests_recalculate_succession - Recalculates the line of succession of the scoped character
Supported Scopes: character

--------------------

send_interface_message - Sends a message to the player playing the character in the scope and then executes any effects inside.
For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.
And $DESC$ contains the text from the desc field.
send_interface_message = {
	type = message_type # default: send_interface_message
	title = LOCALIZATION # optional, otherwise takes it from the message type
	desc = LOCALIZATION # optional, otherwise takes it from the message type
	tooltip = LOCALIZATION # optional, otherwise takes it from the message type
	left_icon = scope:recipient # optional, character or title
	right_icon = scope:the_title # optional, character or title
	goto = scope:the_title # optional, character, barony title, province will add a goto button
		
	# optional effects...
	add_dread = 5
	scope:someone = { add_gold = 5 }
}
Supported Scopes: character

--------------------

send_interface_toast - Sends a message to the player playing the character in the scope and then executes any effects inside.
For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.
And $DESC$ contains the text from the desc field.
send_interface_toast = {
	type = message_type # default: send_interface_toast
	title = LOCALIZATION # optional, otherwise takes it from the message type
	desc = LOCALIZATION # optional, otherwise takes it from the message type
	tooltip = LOCALIZATION # optional, otherwise takes it from the message type
	left_icon = scope:recipient # optional, character or title
	right_icon = scope:the_title # optional, character or title
	goto = scope:the_title # optional, character, barony title, province will add a goto button
		
	# optional effects...
	add_dread = 5
	scope:someone = { add_gold = 5 }
}
Supported Scopes: character

--------------------

set_absolute_country_control - Sets if this character has absolute country control, unlock_character_movement = yes/no/boolean event target
Supported Scopes: character

--------------------

set_age - Sets the character's age. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command
   Usage: set_age = script value
Supported Scopes: character

--------------------

set_beneficiary - The target character becomes the beneficiary of the scoped character. set_beneficiary = some character
Supported Scopes: character
Supported Targets: character

--------------------

set_character_faith - Changes what faith a character has executing the effects for it. For history setup use 'set_character_faith_history' instead.
Supported Scopes: character
Supported Targets: faith

--------------------

set_character_faith_history - Changes what faith a character has NOT executing the effects for it. USE ONLY IN HISOTRY SETUP!
Supported Scopes: character
Supported Targets: faith

--------------------

set_character_faith_with_conversion - Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who'd accept will get converted, as will capitals
Supported Scopes: character
Supported Targets: faith

--------------------

set_child_of_concubine_on_pregnancy - Sets the child to be (or not be) a child of a concubine during pregnancy
Supported Scopes: character

--------------------

set_council_task - Sets the task of the scope councillor { task_type = council_position_type_key target = for_targeted_tasks  }
Supported Scopes: character

--------------------

set_culture - Set the culture for this character
Supported Scopes: character
Supported Targets: culture

--------------------

set_culture_same_as - sets the culture of the character to be the same as the culture of the target
Supported Scopes: character
Supported Targets: character

--------------------

set_death_reason - sets the death reason and the killer of a dead character, set_death_reason = { killer = X death_reason = Y }, both parameters are optional
Supported Scopes: character

--------------------

set_default_education - Set the default education focus for this character
Supported Scopes: character

--------------------

set_designated_heir - Sets the given character as designated heir
Supported Scopes: character
Supported Targets: character

--------------------

set_employer - Add the scope character to the target character's court
Supported Scopes: character
Supported Targets: character

--------------------

set_father - sets the father of a character
Supported Scopes: character
Supported Targets: character

--------------------

set_focus - Set the focus for this character
Supported Scopes: character

--------------------

set_house - Sets the dynasty house of the character
Supported Scopes: character
Supported Targets: dynasty house

--------------------

set_immortal_age - Changes what age the character became immortal at. Only works if already immortal
set_immortal_age = 20
Supported Scopes: character

--------------------

set_killer_public - Sets the scoped character's killer as being publicly known
set_killer_public = bool
Supported Scopes: character

--------------------

set_known_bastard_on_pregnancy - Sets the child to a known or unknown bastard during pregnancy
Supported Scopes: character

--------------------

set_mother - Sets the mother of a character
Supported Scopes: character
Supported Targets: character

--------------------

set_num_pregnancy_children - Set the number of children
Supported Scopes: character

--------------------

set_override_designated_winner - The scoped character will put their beneficiary on the throne if they're the #1 participant if this is called with 'yes'. Call with 'no' to turn it off again. set_override_designate_winner = yes/no
Supported Scopes: character

--------------------

set_player_character - The scope character's player will now play as the target character. Scope must be player-controlled. Target cannot be player-controlled. Example: make_unprunable = yes
Supported Scopes: character
Supported Targets: character

--------------------

set_pregnancy_assumed_father - Set the assumed father of the pregnancy
Supported Scopes: character
Supported Targets: character

--------------------

set_primary_spouse - Set the primary spouse of a character
set_primary_spouse = scope
Supported Scopes: character
Supported Targets: character

--------------------

set_primary_title_to - Sets the primary title for a character
set_primary_title_to = <title>
Supported Scopes: character
Supported Targets: landed title

--------------------

set_real_father - Changes the real father of the character scope
Supported Scopes: character
Supported Targets: character

--------------------

set_realm_capital - Set a new realm capital
character = { set_realm_capital = new_title }
Supported Scopes: character
Supported Targets: landed title

--------------------

set_relation_best_friend - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_bully - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_court_physician - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_crush - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_friend - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_guardian - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_intrigue_mentor - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_intrigue_student - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_lover - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_mentor - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_nemesis - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_oaf - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_potential_friend - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_potential_lover - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_potential_rival - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_rival - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_soldier_friend - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_soulmate - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_student - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_victim - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_relation_ward - Sets scripted relationship
Supported Scopes: character
Supported Targets: character

--------------------

set_sexuality - Sets the sexuality of the character
Supported Scopes: character

--------------------

set_to_lowborn - Set the character to lowborn
Supported Scopes: character

--------------------

set_trait_rank - Sets the trait rank = { trait = trait_group rank = new rank }
Supported Scopes: character

--------------------

set_vassal_contract_modification_blocked - Blocks the vassal contract from being modified with regards to being checked by 'vassal_contract_is_blocked_from_modification'
Supported Scopes: character

--------------------

spawn_army - Spawns an army for this character. If the character is not at war, the regiments will be created, but the army will not be spawned.
Usage:
spawn_army = {
	 levies = int/script value # optional, number of men
	 men_at_arms = { # optional, multiple can be specified. Need either levies or MAA
        type = key
        men/stacks = int/script value
    }
	 location = province
	 origin = province # optional, location used if not set. This is used for where to base bonuses and the like on
	 war = war # optional. If set, the stack will disband after the war ends
	 war_keep_on_attacker_victory = yes/no # Default: no. Tied to a war. Normally the stack will disband upon victory (if a war is specified), but this parameter prevents that from happening upon attacker victory
	 inheritable = yes/no # Default: yes
	 uses_supply = yes/no # Default: yes
	 army = army # optional. If set, the stack will merge into this army
    save_scope_as/save_temporary_scope_as = new_army # optional way to get a reference to the new army. Note this might not be set if the army wasn't spawned (e.g. if the character is not at war)
    name = description # gives the troops a specific name that shows up in interfaces
}
Supported Scopes: character

--------------------

start_default_task - Force the Councillor to revert to the default task. Any relevant percentage progress will be lost (even if the councillor was performing the default task already).
Supported Scopes: character

--------------------

start_scheme - starts a scheme  = { type = X target = Y }
Supported Scopes: character

--------------------

start_war - starts a war  = { casus_belli/cb = X target = Y claimant = Z target_title = W1 target_title = W2 ... } where X is a casus belli type, Y is the target character, Z i the (optional) claimant, W1, W2.... are targeted titles.
If there are no title targets, the effect will pick one of possible title targets.
Supported Scopes: character

--------------------

stress_impact - Stress impact according to specified traits (trait = value), use base = value for a base value that's always added
Supported Scopes: character

--------------------

use_hook - Uses a hook a character has (removes if weak, puts on cooldown if strong), use_hook = some_character
Supported Scopes: character
Supported Targets: character

--------------------

vassal_contract_decrease_obligation_level - decrease the obligation level of the scoped character's vassal contract
Supported Scopes: character

--------------------

vassal_contract_increase_obligation_level - increase the obligation level of the scoped character's vassal contract
Supported Scopes: character

--------------------

vassal_contract_set_obligation_level - change the obligation level of the scoped character's vassal contract
vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level
vassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }
Supported Scopes: character

--------------------

visit_court_of - Add the scope character as the target character's guest
Supported Scopes: character
Supported Targets: character

--------------------

add_faction_discontent - add_faction_discontent = X adds (or subtracts) discontent to the scope faction
Supported Scopes: faction

--------------------

destroy_faction - the scoped faction is destroyed [yes|no]
Supported Scopes: faction

--------------------

every_faction_county_member - Iterate through all faction county members
every_faction_county_member = { limit = { <triggers> } <effects> }
Supported Scopes: faction
Supported Targets: landed title

--------------------

every_faction_member - Iterate through all faction character members
every_faction_member = { limit = { <triggers> } <effects> }
Supported Scopes: faction
Supported Targets: character

--------------------

faction_remove_war - Removes the war currently associated with the faction
faction_remove_war = yes
Supported Scopes: faction

--------------------

faction_start_war - The scope faction starts the war agains their target.
faction_start_war = {
    title = [optional]
} 
Supported Scopes: faction

--------------------

ordered_faction_county_member - Iterate through all faction county members
ordered_faction_county_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faction
Supported Targets: landed title

--------------------

ordered_faction_member - Iterate through all faction character members
ordered_faction_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faction
Supported Targets: character

--------------------

random_faction_county_member - Iterate through all faction county members
random_faction_county_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faction
Supported Targets: landed title

--------------------

random_faction_member - Iterate through all faction character members
random_faction_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faction
Supported Targets: character

--------------------

remove_special_character - Removes the special character for the scope faction
Supported Scopes: faction

--------------------

remove_special_title - Removes the special character for the scope faction
Supported Scopes: faction

--------------------

set_special_character - Sets the special character for the scope faction
Supported Scopes: faction
Supported Targets: character

--------------------

set_special_title - Sets the special title for the scope faction
Supported Scopes: faction
Supported Targets: landed title

--------------------

add_attacker - adds the target character to the scope war as an attacker
Supported Scopes: war
Supported Targets: character

--------------------

add_defender - adds the target character to the scope war as a defender
Supported Scopes: war
Supported Targets: character

--------------------

end_war - ends the war with the specified winner, end_war = attacker/defender/white_peace
Supported Scopes: war

--------------------

every_war_attacker - Iterate through all attackers in the war
every_war_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

every_war_defender - Iterate through all defenders in the war
every_war_defender = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

every_war_participant - Iterate through all participants in the war
every_war_participant = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

ordered_war_attacker - Iterate through all attackers in the war
ordered_war_attacker = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: character

--------------------

ordered_war_defender - Iterate through all defenders in the war
ordered_war_defender = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: character

--------------------

ordered_war_participant - Iterate through all participants in the war
ordered_war_participant = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: character

--------------------

random_war_attacker - Iterate through all attackers in the war
random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

random_war_defender - Iterate through all defenders in the war
random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

random_war_participant - Iterate through all participants in the war
random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: character

--------------------

remove_participant - removes the target character from the scope war
Supported Scopes: war
Supported Targets: character

--------------------

set_called_to - sets the target character as already called to the scope war
Supported Scopes: war
Supported Targets: character

--------------------

set_casus_belli - sets the casus belli of the scope war
Supported Scopes: war

--------------------

activate_holy_site - Activate an inactive holy site<faith_scope> = { activate_holy_site = <holy_site_name> }
Supported Scopes: faith

--------------------

add_doctrine - Add doctrine to faith<faith_scope> = { add_doctrine = <doctrine_name> }
Supported Scopes: faith

--------------------

change_fervor - Changes the fervor of the faith by the given value. change_fervor = script value
Supported Scopes: faith

--------------------

deactivate_holy_site - Deactivate an active holy site<faith_scope> = { deactivate_holy_site = <holy_site_name> }
Supported Scopes: faith

--------------------

every_defensive_great_holy_wars - Iterate through all great holy wars this faith is defending against
every_defensive_great_holy_wars = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: great holy war

--------------------

every_faith_character - Iterate through characters of the scoped faith
every_faith_character = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

every_faith_holy_order - Iterate through all holy orders of the faith
every_faith_holy_order = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: holy order

--------------------

every_faith_playable_ruler - Iterate through playable rulers of the scoped faith
every_faith_playable_ruler = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

every_faith_ruler - Iterate through rulers of the scoped faith
every_faith_ruler = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

every_holy_site - Iterate through all holy site baronies of a faith
every_holy_site = { limit = { <triggers> } <effects> }
Supported Scopes: faith
Supported Targets: landed title

--------------------

ordered_defensive_great_holy_wars - Iterate through all great holy wars this faith is defending against
ordered_defensive_great_holy_wars = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: great holy war

--------------------

ordered_faith_character - Iterate through characters of the scoped faith
ordered_faith_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

ordered_faith_holy_order - Iterate through all holy orders of the faith
ordered_faith_holy_order = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: holy order

--------------------

ordered_faith_playable_ruler - Iterate through playable rulers of the scoped faith
ordered_faith_playable_ruler = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

ordered_faith_ruler - Iterate through rulers of the scoped faith
ordered_faith_ruler = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

ordered_holy_site - Iterate through all holy site baronies of a faith
ordered_holy_site = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: faith
Supported Targets: landed title

--------------------

random_defensive_great_holy_wars - Iterate through all great holy wars this faith is defending against
random_defensive_great_holy_wars = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: great holy war

--------------------

random_faith_character - Iterate through characters of the scoped faith
random_faith_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

random_faith_holy_order - Iterate through all holy orders of the faith
random_faith_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: holy order

--------------------

random_faith_playable_ruler - Iterate through playable rulers of the scoped faith
random_faith_playable_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

random_faith_ruler - Iterate through rulers of the scoped faith
random_faith_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: character

--------------------

random_holy_site - Iterate through all holy site baronies of a faith
random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: faith
Supported Targets: landed title

--------------------

remove_doctrine - Remove doctrine from faith<faith_scope> = { remove_doctrine = <doctrine_name> }
Supported Scopes: faith

--------------------

remove_religious_head_title - Removes the religious head title of the faith
remove_religious_head_title = yes
Supported Scopes: faith

--------------------

set_religious_head_title - Sets the religious head title of the faith to the given title. set_religious_head_title = scope
Supported Scopes: faith
Supported Targets: landed title

--------------------

start_great_holy_war - Starts a great holy war.
start_great_holy_war = {target_character = someonetarget_title = some titledelay = script value # Number of days until the war should startwar = some war # Optional. Will make this a directed GHW instead of undirected, and tie it to this specific war}
Supported Scopes: faith

--------------------

add_secret_participant - Adds an participant to the secret
Supported Scopes: secret
Supported Targets: character

--------------------

disable_exposure_by - Forbids the target character from exposing the secret, disable_exposure_by = target_character
Supported Scopes: secret
Supported Targets: character

--------------------

every_secret_knower - Iterate through all characters who know the secret
every_secret_knower = { limit = { <triggers> } <effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

every_secret_participant - Iterate through participants in a secret
every_secret_participant = { limit = { <triggers> } <effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

expose_secret - Exposes the scope secret
Supported Scopes: secret
Supported Targets: character

--------------------

ordered_secret_knower - Iterate through all characters who know the secret
ordered_secret_knower = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

ordered_secret_participant - Iterate through participants in a secret
ordered_secret_participant = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

random_secret_knower - Iterate through all characters who know the secret
random_secret_knower = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

random_secret_participant - Iterate through participants in a secret
random_secret_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: secret
Supported Targets: character

--------------------

remove_secret - Removes the scope secret
Supported Scopes: secret

--------------------

reveal_to - Reveals the scope secret to the target character
Supported Scopes: secret
Supported Targets: character

--------------------

set_secret_owner - Sets a new owner for the secret
Supported Scopes: secret
Supported Targets: character

--------------------

spend_by - Spends the scope secret, spend_by = target_character
Supported Scopes: secret
Supported Targets: character

--------------------

generate_coa - Generates a coat of arms for the scoped landed title, dynasty or house
generate_coa = yes
Supported Scopes: landed title, dynasty, dynasty house

--------------------

reset_coa - Rest the coat of arms for the scoped landed title, dynasty or house to its template
reset_coa = yes
Supported Scopes: landed title, dynasty, dynasty house

--------------------

set_coa - Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type
set_coa = k_england
set_coa = scope:new_coa
Supported Scopes: landed title, dynasty, dynasty house

--------------------

add_building - Add building to the province<province> = { add_building = <building_name> }
Supported Scopes: province

--------------------

add_building_slot - Add building slot to the province
Supported Scopes: province

--------------------

add_province_modifier - Add a modifier to a province
add_province_modifier = name
add_province_modifier = { modifier = name days/weeks/months/years = int }
You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
Supported Scopes: province

--------------------

add_special_building - Add a special building to the province (will also add/change a special slot if needed)
Supported Scopes: province

--------------------

add_special_building_slot - Add a special building slot to the province<province> = { add_special_building_slot = <building_name> }
Supported Scopes: province

--------------------

generate_building - Adds a random building to the province, using the AI's construction logic<province> = { generate_building = yes }
Supported Scopes: province

--------------------

refill_garrison - The scoped province gets its garrison refilled. refill_levy = yes/no
Supported Scopes: province

--------------------

refill_levy - The scoped province gets its levy refilled. refill_levy = yes/no
Supported Scopes: province

--------------------

remove_all_province_modifier_instances - Remove all instances of a modifier from a province
remove_all_province_modifier_instances = name
Supported Scopes: province

--------------------

remove_province_modifier - Remove a modifier from a province
remove_province_modifier = name
Supported Scopes: province

--------------------

set_holding_type - Changes the scoped province's holding to another type, removing all buildings that are invalid for the new holding.
This might also allow to construct a new holding in an empty province, but it is untested.
Supported Scopes: province

--------------------

spawn_activity - spawns an activity, spawn_activity = { owner = X type = Y days/months/years = Z }, Z is expiration time can be a value or an inclusive "{A B}" interval from which the value will be picked
Supported Scopes: province

--------------------

every_leased_title - Iterate through all titles leased to a holy order
every_leased_title = { limit = { <triggers> } <effects> }
Supported Scopes: holy order
Supported Targets: landed title

--------------------

ordered_leased_title - Iterate through all titles leased to a holy order
ordered_leased_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: holy order
Supported Targets: landed title

--------------------

random_leased_title - Iterate through all titles leased to a holy order
random_leased_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: holy order
Supported Targets: landed title

--------------------

accept_invitation_for_character - accept a characters invitation to the activity
Supported Scopes: activity
Supported Targets: character

--------------------

decline_invitation_for_character - decline a characters invitation to the activity
Supported Scopes: activity
Supported Targets: character

--------------------

every_activity_declined - Iterate through all characters who declined an activity invite to a specific activity
every_activity_declined = { limit = { <triggers> } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

every_activity_invited - Iterate through all characters who have unanswered invites to a specific activity
every_activity_invited = { limit = { <triggers> } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

every_participant - Iterate through all participants in an activity
every_participant = { limit = { <triggers> } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

invite_character_to_activity - invite a character to the activity
Supported Scopes: activity
Supported Targets: character

--------------------

ordered_activity_declined - Iterate through all characters who declined an activity invite to a specific activity
ordered_activity_declined = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

ordered_activity_invited - Iterate through all characters who have unanswered invites to a specific activity
ordered_activity_invited = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

ordered_participant - Iterate through all participants in an activity
ordered_participant = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

random_activity_declined - Iterate through all characters who declined an activity invite to a specific activity
random_activity_declined = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

random_activity_invited - Iterate through all characters who have unanswered invites to a specific activity
random_activity_invited = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

random_participant - Iterate through all participants in an activity
random_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: activity
Supported Targets: character

--------------------

add_from_contribution_attackers - Adds prestige, gold and piety based on contribution to allied attackers. parameters: prestige, gold, piety.
Supported Scopes: casus belli

--------------------

add_from_contribution_defenders - Adds prestige, gold and piety based on contribution to allied defenders. parameters: prestige, gold, piety.
Supported Scopes: casus belli

--------------------

every_target_title - Iterate through all casus belli's target titles
every_target_title = { limit = { <triggers> } <effects> }
Supported Scopes: casus belli
Supported Targets: landed title

--------------------

ordered_target_title - Iterate through all casus belli's target titles
ordered_target_title = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: casus belli
Supported Targets: landed title

--------------------

random_target_title - Iterate through all casus belli's target titles
random_target_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: casus belli
Supported Targets: landed title

--------------------

add_loot - Adds loot to the currently scoped raiding army.
Usage:
	add_loot = VALUE
Supported Scopes: army

--------------------

assign_commander - Assign a commander for the scoped army
set_commander = scope:a_character
Supported Scopes: army
Supported Targets: character

--------------------

remove_commander - Removes the currently assigned commander from the scoped army
remove_commander = yes
Supported Scopes: army

--------------------

set_army_location - Teleports the army to the given location. Cannot be done while in combat. Will cause combat to happen with this army as the attacker if there's hostiles in the target
set_army_location = scope:province
Supported Scopes: army
Supported Targets: province

--------------------

add_diplomacy_skill - Adds diplomacy skill
Supported Scopes: none

--------------------

add_focus_progress - Adds focus progress
Supported Scopes: none

--------------------

add_internal_flag - adds effect to be read internally (no effect in the gamestate)
Supported Scopes: none

--------------------

add_intrigue_skill - Adds intrigue skill
Supported Scopes: none

--------------------

add_learning_skill - Adds learning skill
Supported Scopes: none

--------------------

add_martial_skill - Adds martial skill
Supported Scopes: none

--------------------

add_prowess_skill - Adds prowess skill
Supported Scopes: none

--------------------

add_stewardship_skill - Adds stewardship skill
Supported Scopes: none

--------------------

add_title_law - add law to scoped title, overriding any current law from the same group. DOES NOT apply law change costs and effects.
add_title_law = princely_elective_succession_law
Supported Scopes: none

--------------------

add_title_law_effects - add law to scoped title, overriding any current law from the same group. DOES apply law change costs and effects.
add_title_law = princely_elective_succession_law
Supported Scopes: none

--------------------

add_to_global_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

add_to_list - Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain
add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
Supported Scopes: none

--------------------

add_to_local_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

add_to_temporary_list - Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect
add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent
Supported Scopes: none

--------------------

add_to_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

assert_if - Conditionally cause an assert during run time
assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
Supported Scopes: none

--------------------

assert_read - Conditionally cause an assert during read time
assert_read = X, where X is yes or the string to be printed in the assert
Supported Scopes: none

--------------------

break_betrothal - Breaks the betrothal between the scope character to the target character, break_betrothal = target
Supported Scopes: none
Supported Targets: character

--------------------

change_global_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

change_local_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

change_title_holder -  = {
holder = 'Character that should get the title'
change = 'previously created title_and_vassal_change', adds a title change, will not transfer vassalstake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a countygovernment_base = character # Optional, if the character getting the title was unlanded, their new government will be based on the government of government_base. If no government_base is specified, the government will be based on holder's government.
Supported Scopes: none

--------------------

change_title_holder_include_vassals -  = {
holder = 'Character that should get the title'
change = 'previously created title_and_vassal_change', adds a title change, will transfer vassalstake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a countygovernment_base = character # Optional, if the character getting the title was unlanded, their new government will be based on the government of government_base. If no government_base is specified, the government will be based on holder's government.
Supported Scopes: none

--------------------

change_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

clamp_global_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clamp_local_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clamp_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clear_global_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

clear_local_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

clear_saved_scope - Clears a saved scope from the top scope
save_scope_as = cool_scope -> clear_saved_scope = cool_scope
Supported Scopes: none

--------------------

clear_traits - Removes all traits for the character. clear_traits = yes
Supported Scopes: none

--------------------

clear_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

close_all_views - Closes all views. close_all_views = yes
Supported Scopes: none

--------------------

close_view - Tries to close the defined view.
Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.
close_view = {
    view = <view name>
    player = scope:character # optional, else closes for all players who execute the effect
}simplified: close_view = <view name>
Supported Scopes: none

--------------------

complete_activity - completes the activity, complete_activity = yes ends the activity and runs the on_complete effect, complete_activity = no ends the activity without running the effect
Supported Scopes: none

--------------------

copy_traits - Adds all traits of the target to the character. Skips any traits that the character isn't allowed to have. Will not remove the character's existing traits. copy_traits = scope:character
Supported Scopes: none
Supported Targets: character

--------------------

create_betrothal - Betroth the scope character to the target character, create_betrothal = target (at least one of the characters need to not be adult)
Supported Scopes: none
Supported Targets: character

--------------------

create_betrothal_matrilineal - Betroth the scope character to the target character matrilineally, create_betrothal_matrilineal = target (at least one of the characters need to not be adult)
Supported Scopes: none
Supported Targets: character

--------------------

create_character - Creates a character

save_event_target_as = flag - save the character as an event target
save_temporary_event_target_as = flag - save the character as a temporary event target
name = 
age = 
gender = male/female/character scope
gender_female_chance = script_value - Range (0..100)
opposite_gender = character scope
trait = add this trait
random_traits_list = { count = { 1 5 } traitID = { some triggers } traitID = { some triggers } } - A number of traits specified by count (1 if not specified) will be picked from the traits that have their triggers met. Scopes are the same as where create_character is used. More than one grouping like this can be defined 
random_traits = yes/no
health = 
fertility = 
mother = 
father = 
real_father = (should only be set if the real father is not the same as father=)
employer = will end up in this court, will become a pool character unless specified or father/mother is landed
location = pool province; mutually exclusive with employer
template_character = 
faith, culture and dynasty are set from 1. template_character 2. father 3. mother 4. employer (not employer for dynasty) unless specified directly
faith = faith tag OR a faith scope
random_faith = { catholic = { some triggers } cathar = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used 
random_faith_in_religion = religion tag OR a faith scope (there's no religion scope)
culture = culture name OR a culture scope
random_culture = { norse = { some triggers } norwegian = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used 
random_culture_in_group = culture group name OR a culture scope (there's no group scope)
dynasty_house = dynasty house name OR a dynasty house scope
dynasty = generate/inherit/none - What to do if dynasty_house is not specified. generate by default.
martial/diplomacy/intrigue...  =  will get random unless specified
after_creation = { some effects } run after character is created. Scope starts off in the character, with the scope it was created in as PREV, and the same top scope and saved targets etc.
Supported Scopes: none

--------------------

create_dynamic_title - Creates a dynamic title
The title will be saved to scope:new_titleusage:
create_dynamic_title = {
	tier = <tier>
	name = key/dynamic description	adjective = key/dynamic description (optional; name used if not specified)}
Supported Scopes: none

--------------------

create_holy_order - Create a new holy order
create_holy_order = {
    leader = scope:a_character
    capital = scope:a_barony_title
    save_scope_as/save_temporary_scope_as = new_holy_order # optional way to get a reference to the new holy order
}
Supported Scopes: none

--------------------

create_title_and_vassal_change - starts a title and vassal change and saves it as a temporary event target
create_title_and_vassal_change = {
type = conquest (or other type)
save_scope_as = change (name of resulting saved scope)
add_claim_on_loss = yes (optional)
}
Supported Scopes: none

--------------------

custom_description - Wraps effects that get a custom description instead of the auto-generated one
custom_description = {
	text = <effect_localization_key>
	subject = <optional subject scope> #defaults to current scope
	object = <optional object scope>
	value = <optional script value>
	... effects ...
}
Supported Scopes: none

--------------------

custom_description_no_bullet - Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears
custom_description_no_bullet = {
	text = <effect_localization_key>
	subject = <optional subject scope> #defaults to current scope
	object = <optional object scope>
	value = <optional script value>
	... effects ...
}
Supported Scopes: none

--------------------

custom_label - just a tooltip, the scope as object (for grouping, localization)
Supported Scopes: none

--------------------

custom_tooltip - just a tooltip, the scope as subject (for grouping, localization)
Supported Scopes: none

--------------------

debug_log - Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
Supported Scopes: none

--------------------

debug_log_date - Logs the current date to the debug.log
Supported Scopes: none

--------------------

debug_log_scopes - Log the current scope to the debug log when this effect executes yes = full scope info, no=only current scope
Supported Scopes: none

--------------------

debug_trigger_event - Like trigger_event, except it'll print the trigger fulfillment and immediate effects of the event too
Supported Scopes: none

--------------------

divorce - Divorces the scope character from the target character. divorce = target
Supported Scopes: none
Supported Targets: character

--------------------

duel - duel effect that selects an effect based on comparing specified skill of a character to a value or another character's skill. Alternatively, the compare value can be scripted completely
duel = {
    skill = X
    target = Y
    value = Z
    localization = W
    ... random list body
}
Where X is the skill to compare, Y is the target character (requires skill to be set) or integer value Z (works with or without the skill), the rest of the effect is the same as random_list
If the skill is unspecified, the effect needs a value Z (which can use scripted math) which it will then use as the duel vlue directly
If localization = W is specified, the effect localization W will be used (entry in effect_localization database, not a localization key directly)
The skill difference (or scripted duel value) is available as scope:duel_value inside the outcome entries, the duel target is accessible as scope:duel_target
Valid skill, target, combinations: skill + target, skill + value, only value

Since there is now no automatic weighting, we should be using weight numbers in a comparable range to the scope:duel_value value. Since that will always be between -20 and 20 (unless you do something very unusual), and typically in a more narrow range than that, we should stick to those ranges.
Only use larger weights if you want the duel_value to have a smaller impact on the weighting, and only use smaller weights if you want the duel_value to have a huge impact on the weighting.
In addition, it is fully possible for the compare_modifier to reduce the weight to 0, which would mean that it will not be possible to happen at all. I've requested code support to make it so that we can define min and max values for weights, but until further notice we should use ranges that are guaranteed to not hit 0, or include min values in the compare_modifier itself.
Lastly, remember that if you want the outcome of a duel to scale linearly from (almost) 0% to (almost) 100%, the duel_value should be applied 50% to the good outcome, and -50% to the bad outcome. If you only apply it on one side, you will retain a (presumably significant) chunk of chance for the other outcome.
Supported Scopes: none

--------------------

else - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
if = { limit = { <triggers> } <effects> }
else = { <effects> }
Supported Scopes: none

--------------------

else_if - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
if = { limit = { <triggers> } <effects> }
else_if = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_barony - Iterate through all baronies in the game
every_barony = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_county - Iterate through all counties in the game
every_county = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_county_in_region - Iterate through all counties in the region. Put 'region = region_name' inside it
every_county_in_region = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_culture_global - Iterate through all cultures in the game
every_culture_global = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: culture

--------------------

every_duchy - Iterate through all duchies in the game
every_duchy = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_empire - Iterate through all empires in the game
every_empire = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_in_global_list - Iterate through all items in global list. list = name or variable = name
every_in_global_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_in_list - Iterate through all items in list. list = name or variable = name
every_in_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_in_local_list - Iterate through all items in local list. list = name or variable = name
every_in_local_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_independent_ruler - Independent rulers list with a COUNT tier o above
every_independent_ruler = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

every_kingdom - Iterate through all kingdoms in the game
every_kingdom = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

every_living_character - Iterate through all living characters
every_living_character = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

every_player - Iterate through all player characters
every_player = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

every_pool_character - Iterate through all characters in the pool of the given province
every_pool_character = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

every_province - Iterate through all provinces (skips non-land and impassable provinces)
every_province = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

every_religion_global - Iterate through all religions in the game
every_religion_global = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: religion

--------------------

every_ruler - Rulers list with a COUNT tier o above
every_ruler = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

hidden_effect - Effect not shown in tooltips
Supported Scopes: none

--------------------

if - Executes enclosed effects if limit criteria are met
if = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

multiply_focus_progress - Multiplies focus progress
Supported Scopes: none

--------------------

open_interaction_window - Tries to open the defined view.

interaction = interaction_key - the interaction object key to open
redirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)
actor = character_actor - must be defined, must coincide with the current player
recipient = character_actor - must be defined
secondary_actor = character_secontary_actor - optional
secondary_recipient = character_secondary_recipient - optional
Supported Scopes: none

--------------------

open_view - Tries to open the defined view without scope data.
Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.
open_view = {
    view = <view name>
    view_message = <view specific instruction> # optional
    player = scope:character # optional, else shows for all players who execute the effect
}simplified: open_view = <view name>
Supported Scopes: none

--------------------

open_view_data - Tries to open the defined view with scope data.
Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.
open_view_data = {
    view = <view name>
    view_message = <view specific instruction> # optional
    player = scope:character # optional, else shows for all players who execute the effect
}
simplified: open_view_data = <view name>
for example: scope:faith = { open_view_data = faith_conversion }
Supported Scopes: none

--------------------

ordered_barony - Iterate through all baronies in the game
ordered_barony = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_county - Iterate through all counties in the game
ordered_county = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_county_in_region - Iterate through all counties in the region. Put 'region = region_name' inside it
ordered_county_in_region = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_culture_global - Iterate through all cultures in the game
ordered_culture_global = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: culture

--------------------

ordered_duchy - Iterate through all duchies in the game
ordered_duchy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_empire - Iterate through all empires in the game
ordered_empire = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_in_global_list - Iterate through all items in global list. list = name or variable = name
ordered_in_global_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_in_list - Iterate through all items in list. list = name or variable = name
ordered_in_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_in_local_list - Iterate through all items in local list. list = name or variable = name
ordered_in_local_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_independent_ruler - Independent rulers list with a COUNT tier o above
ordered_independent_ruler = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: character

--------------------

ordered_kingdom - Iterate through all kingdoms in the game
ordered_kingdom = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

ordered_living_character - Iterate through all living characters
ordered_living_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: character

--------------------

ordered_player - Iterate through all player characters
ordered_player = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: character

--------------------

ordered_pool_character - Iterate through all characters in the pool of the given province
ordered_pool_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: character

--------------------

ordered_province - Iterate through all provinces (skips non-land and impassable provinces)
ordered_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: province

--------------------

ordered_religion_global - Iterate through all religions in the game
ordered_religion_global = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: religion

--------------------

ordered_ruler - Rulers list with a COUNT tier o above
ordered_ruler = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: character

--------------------

pan_camera_to_province - Pans the camera to the specified province
pan_camera_to_province = scope:army.location
Supported Scopes: none
Supported Targets: province

--------------------

pan_camera_to_title - Pans the camera to the specified title
pan_camera_to_title = capital_barony
Supported Scopes: none
Supported Targets: landed title

--------------------

random - a random effect, random = { chance = X modifier = Y effects... }
where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y
Supported Scopes: none

--------------------

random_barony - Iterate through all baronies in the game
random_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_county - Iterate through all counties in the game
random_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_county_in_region - Iterate through all counties in the region. Put 'region = region_name' inside it
random_county_in_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_culture_global - Iterate through all cultures in the game
random_culture_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: culture

--------------------

random_duchy - Iterate through all duchies in the game
random_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_empire - Iterate through all empires in the game
random_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_in_global_list - Iterate through all items in global list. list = name or variable = name
random_in_global_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_in_list - Iterate through all items in list. list = name or variable = name
random_in_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_in_local_list - Iterate through all items in local list. list = name or variable = name
random_in_local_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_independent_ruler - Independent rulers list with a COUNT tier o above
random_independent_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

random_kingdom - Iterate through all kingdoms in the game
random_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: landed title

--------------------

random_list - a random list effect
random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }
Selects one effect from the list and fires it. The effects are weighted by numbers X1, X2... (the higher the number, the higher the chance of the effect being picked).
The chances can be modified by optional value modifier lists Y1, Y2... (AKA MTTH)
Supported Scopes: none

--------------------

random_living_character - Iterate through all living characters
random_living_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

random_log_scopes - Log the current scope to the random log when this effect executes. Only use temprorarily for debugging purposes as it can introduce localized strings into the Scopes._Random log. yes = full scope info, no=only current scope
Supported Scopes: none

--------------------

random_player - Iterate through all player characters
random_player = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

random_pool_character - Iterate through all characters in the pool of the given province
random_pool_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

random_province - Iterate through all provinces (skips non-land and impassable provinces)
random_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

random_religion_global - Iterate through all religions in the game
random_religion_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: religion

--------------------

random_ruler - Rulers list with a COUNT tier o above
random_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: character

--------------------

remove_from_list - Removes the current scope from a named list remove_from_list = <string>
Supported Scopes: none

--------------------

remove_global_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

remove_list_global_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_list_local_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_list_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_local_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

remove_title_law - remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES NOT apply law removal costs and effects.
remove_title_law = princely_elective_succession_law
Supported Scopes: none

--------------------

remove_title_law_effects - remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES apply law removal costs and effects.
remove_title_law = princely_elective_succession_law
Supported Scopes: none

--------------------

remove_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

resolve_title_and_vassal_change - resolve_title_and_vassal_change = scope:change
Execute and destory the target title and vassal change, the change cannot be used after calling this effect
Supported Scopes: none
Supported Targets: title and vassal change

--------------------

round_global_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

round_local_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

round_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

save_opinion_value_as - Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_opinion_value_as = { name = <string> target = x }
Supported Scopes: none

--------------------

save_scope_as - Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_event_target_as = <string>
Supported Scopes: none

--------------------

save_scope_value_as - Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_scope_value_as = { name = <string> value = x }
Supported Scopes: none

--------------------

save_temporary_opinion_value_as - Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the in the same effect
save_temporary_opinion_value_as = { name = <string> target = x 
Supported Scopes: none

--------------------

save_temporary_scope_as - Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect
save_temporary_event_target_as = <string>
Supported Scopes: none

--------------------

save_temporary_scope_value_as - Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect
save_temporary_scope_value_as = { name = <string> value = x }
Supported Scopes: none

--------------------

set_focus_progress - Sets focus progress
Supported Scopes: none

--------------------

set_generated_asexuality_chance - Sets the chance for a generated character to be asexual
set_generated_asexuality_chance = 20
Supported Scopes: none

--------------------

set_generated_bisexuality_chance - Sets the chance for a generated character to be bisexual
set_generated_bisexuality_chance = 20
Supported Scopes: none

--------------------

set_generated_homosexuality_chance - Sets the chance for a generated character to be homosexual
set_generated_homosexuality_chance = 20
Supported Scopes: none

--------------------

set_global_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Can also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })
Supported Scopes: none

--------------------

set_local_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Can also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })
Supported Scopes: none

--------------------

set_pregnancy_gender - Set the gender of the unborn child
set_pregnancy_gender = female/male/random
Supported Scopes: none

--------------------

set_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Can also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })
Supported Scopes: none

--------------------

setup_claim_cb -  = { attacker = scope:attacker 
 defender = scope:defender 
 claimant = scope:claimant 
  change = scope:change victory = yes/no 
 take_occupied = yes/no } , this effect will add a scope:cb_prestige_factor with a value based on what's being taken
civil_war = yes # Will vassalize people based on their capital location rather than being fully contained. Won't steal land from people not vassalized
Supported Scopes: none

--------------------

setup_de_jure_cb -  = { attacker = scope:attacker 
defender = scope:defender 
change = scope:change
victory = yes/no
title = some title - Optional; will make it target a specific dejure title rather than *everything* that is dejure the attacker's
}, this effect will add a scope:cb_prestige_factor with a value based on what's being taken
Supported Scopes: none

--------------------

setup_invasion_cb -  = { attacker = scope:attacker 
 defender = scope:defender 
  change = scope:change victory = yes/no 
 take_occupied = yes/no } , this effect will add a scope:cb_prestige_factor with a value based on what's being taken
Supported Scopes: none

--------------------

show_as_tooltip - Effect only shown in tooltips (but not executed)
Supported Scopes: none

--------------------

start_tutorial_lesson - Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)
Supported Scopes: none

--------------------

switch - Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.
switch = {
	trigger = simple_assign_trigger
	case_1 = { <effects> }
	case_2 = { <effects> }
	case_n = { <effects> }
	fallback = { <effects> }
Supported Scopes: none

--------------------

trigger_event - triggers an event or on_action
trigger_event = { id = X days/months/years = Y delayed = yes/no } (for events)
or
trigger_event = { on_action = X days/months/years = Y delayed = yes/no } (for on_actions)
Days/months/years are optional and equal to 0 if not specified. If specified, Y can be a value or an inclusive interval "{ A B }" from which the duration will be picked Scopes._Randomly.
delayed = yes will delay the event/on_action to the next event tick even when there's no explicit time interval set (delay, but fire ASAP). By default, delayed = no
Supported Scopes: none

--------------------

try_create_important_action - Tries to create an important action notification. Will keep the current one if already exists.

important_action_type = important_action_type_key - the important action object key to create. Must be defined.
actor = character_actor - optional, can be used by the important action effect
recipient = character_actor - optional, can be used by the important action effect
secondary_actor = character_secontary_actor - optional, can be used by the important action effect
secondary_recipient = character_secondary_recipient - optional, can be used by the important action effect
landed_title = landed_title - optional, can be used by the important action effect
Supported Scopes: none

--------------------

try_create_suggestion - Tries to create an suggestuib notification. Will keep the current one if already exists.

suggestion_type = suggestion_type_key - the suggestion action object key to create. Must be defined.
actor = character_actor - optional, can be used by the suggestion effect
recipient = character_actor - optional, can be used by the suggestion effect
secondary_actor = character_secontary_actor - optional, can be used by the suggestion effect
secondary_recipient = character_secondary_recipient - optional, can be used by the suggestion effect
landed_title = landed_title - optional, can be used by the suggestion effect
Supported Scopes: none

--------------------

while - Repeats enclosed effects while limit criteria are met or until set iteration count is reached
while = { limit = { <triggers> } <effects> }
 while = { count = 3 <effects> }
Default max of 1000.
Supported Scopes: none

--------------------

battle_event - Makes a battle event show up in combat, and the combat result summary. The key is used for loc, with '_friendly' or '_enemy' appended. If this side is not the player's side, the two portraits get flipped. battle_event = { left_portrait = someone right_portrait = someone key = string }
Supported Scopes: combat side

--------------------

every_side_commander - Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
every_side_commander = { limit = { <triggers> } <effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

every_side_knight - Iterate through all knights
every_side_knight = { limit = { <triggers> } <effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

lose_combat - ends the combat as the losing side (doesn't end the combat if evaluated to false)
Supported Scopes: combat side

--------------------

ordered_side_commander - Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
ordered_side_commander = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

ordered_side_knight - Iterate through all knights
ordered_side_knight = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

random_side_commander - Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
random_side_commander = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

random_side_knight - Iterate through all knights
random_side_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: combat side
Supported Targets: character

--------------------

win_combat - ends the combat as the winning side (doesn't end the combat if evaluated to false)
Supported Scopes: combat side

--------------------

change_war_chest_gold - Changes the amount of gold in the war chest by the given amount. change_war_chest_gold = script value
Supported Scopes: great holy war

--------------------

change_war_chest_piety - Changes the amount of piety in the war chest by the given amount. change_war_chest_piety = script value
Supported Scopes: great holy war

--------------------

change_war_chest_prestige - Changes the amount of prestige in the war chest by the given amount. change_war_chest_prestige = script value
Supported Scopes: great holy war

--------------------

divide_war_chest - The scoped GHW gives out its war-chest in full or in part.
divide_war_chest = {
	defenders = yes (default to attackers instead)
	faction = script value (default 1 for 100%)
	gold = no (default = yes)
	piety = no (default = yes)
	prestige = no (default = yes)
}
Supported Scopes: great holy war

--------------------

do_ghw_title_handout - Hands out titles in the target kingdom to the GHW attacker beneficiaries. Will vassalize people based on dejure liege within the taken kingdom. Will refill county garrisons and levies. do_ghw_title_handout = scope:title_and_vassal_change
Supported Scopes: great holy war
Supported Targets: title and vassal change

--------------------

every_pledged_attacker - Iterate through all pledged attackers within a great holy war
every_pledged_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

every_pledged_defender - Iterate through all pledged defenders within a great holy war
every_pledged_defender = { limit = { <triggers> } <effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

ordered_pledged_attacker - Iterate through all pledged attackers within a great holy war
ordered_pledged_attacker = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

ordered_pledged_defender - Iterate through all pledged defenders within a great holy war
ordered_pledged_defender = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

pledge_attacker - The target character pledges themselves as an attacker in the GHW. Must be of the same faith as the GHW declarer. pledge_attacker = some character
Supported Scopes: great holy war
Supported Targets: character

--------------------

pledge_defender - The target character pledges themselves as a defender in the GHW. Must be of the same faith as the GHW target. pledge_defender = some character
Supported Scopes: great holy war
Supported Targets: character

--------------------

random_pledged_attacker - Iterate through all pledged attackers within a great holy war
random_pledged_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

random_pledged_defender - Iterate through all pledged defenders within a great holy war
random_pledged_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: great holy war
Supported Targets: character

--------------------

reset_designated_winner - The GHW stops having a designated winner. reset_designated_winner = yes
Supported Scopes: great holy war

--------------------

set_designated_winner - The target character becomes the designated winner of the GHW. set_designated_winner = some character
Supported Scopes: great holy war
Supported Targets: character

--------------------

set_great_holy_war_target - Sets the target of the great holy war.
set_great_holy_war_target = { target_character = someone target_title = some title }
Supported Scopes: great holy war

--------------------

set_war_declarer - The target character becomes the character that should declare war instead of the religious head. set_war_declarer = some character
Supported Scopes: great holy war
Supported Targets: character

--------------------

start_ghw_war - Starts the GHW war. start_ghw_war = undirected_great_holy_war
Supported Scopes: great holy war

--------------------

unpledge_attacker - The target character removes their pledge as an attacker in the GHW. unpledge_attacker = some character
Supported Scopes: great holy war
Supported Targets: character

--------------------

unpledge_defender - The target character removes their pledge as a defender in the GHW. unpledge_defender = some character
Supported Scopes: great holy war
Supported Targets: character
